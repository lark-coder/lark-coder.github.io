<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hudi.tech","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="1.什么是事务？事务由一组操作组成，我们希望这组操作能够全部正确运行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务的所有操作，要么全部正确执行，要么全部不要执行。 2.事务的四大特性ACID原子性：Atomicity原子性要求，事务是不可分割的执行单元，事务中的所有操作要么全部执行，要么全部不执行。">
<meta property="og:type" content="article">
<meta property="og:title" content="事务的基本概念">
<meta property="og:url" content="http://www.hudi.tech/2019/03/16/%E6%8A%80%E8%83%BD%E7%AF%87/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="木刻的鱼儿的博客">
<meta property="og:description" content="1.什么是事务？事务由一组操作组成，我们希望这组操作能够全部正确运行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务的所有操作，要么全部正确执行，要么全部不要执行。 2.事务的四大特性ACID原子性：Atomicity原子性要求，事务是不可分割的执行单元，事务中的所有操作要么全部执行，要么全部不执行。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709220001.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709230002.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709230003.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709240001.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709240002.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709250001.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709250002.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709250003.jpg">
<meta property="og:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709260001.jpg">
<meta property="article:published_time" content="2019-03-16T13:37:01.000Z">
<meta property="article:modified_time" content="2020-09-05T09:10:18.011Z">
<meta property="article:author" content="不登山峰，不显平地">
<meta property="article:tag" content="java">
<meta property="article:tag" content="springboot">
<meta property="article:tag" content="分布式事务">
<meta property="article:tag" content="事务">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.hudi.tech/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709220001.jpg">

<link rel="canonical" href="http://www.hudi.tech/2019/03/16/%E6%8A%80%E8%83%BD%E7%AF%87/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>事务的基本概念 | 木刻的鱼儿的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>



<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木刻的鱼儿的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.hudi.tech/2019/03/16/%E6%8A%80%E8%83%BD%E7%AF%87/%E4%BA%8B%E5%8A%A1/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="不登山峰，不显平地">
      <meta itemprop="description" content="木鱼者，相传云，鱼昼夜常醒，刻木像形击之，所以警昏情也。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木刻的鱼儿的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          事务的基本概念
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-03-16 21:37:01" itemprop="dateCreated datePublished" datetime="2019-03-16T21:37:01+08:00">2019-03-16</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-05 17:10:18" itemprop="dateModified" datetime="2020-09-05T17:10:18+08:00">2020-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E8%83%BD%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">技能篇</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E8%83%BD%E7%AF%87/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%8A%80%E8%83%BD%E7%AF%87/java/%E4%BA%8B%E5%8A%A1/" itemprop="url" rel="index"><span itemprop="name">事务</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a>1.什么是事务？</h1><p>事务由一组操作组成，我们希望这组操作能够全部正确运行，如果这一组操作中的任意一个步骤发生错误，那么就需要回滚之前已经完成的操作。也就是同一个事务的所有操作，要么全部正确执行，要么全部不要执行。</p>
<h1 id="2-事务的四大特性ACID"><a href="#2-事务的四大特性ACID" class="headerlink" title="2.事务的四大特性ACID"></a>2.事务的四大特性ACID</h1><h2 id="原子性：Atomicity"><a href="#原子性：Atomicity" class="headerlink" title="原子性：Atomicity"></a>原子性：Atomicity</h2><p>原子性要求，事务是不可分割的执行单元，事务中的所有操作要么全部执行，要么全部不执行。</p>
<h2 id="一致性：Consistency"><a href="#一致性：Consistency" class="headerlink" title="一致性：Consistency"></a>一致性：Consistency</h2><p>一致性要求，事务在开始前和结束后，数据库的完整性约束没有被破坏。</p>
<h2 id="隔离性：Isolation"><a href="#隔离性：Isolation" class="headerlink" title="隔离性：Isolation"></a>隔离性：Isolation</h2><p>事务的执行是相互独立的，它们不会相互干扰，一个事务不会看到另一个正在运行过程中的事务的数据。</p>
<h2 id="持久性：Durability"><a href="#持久性：Durability" class="headerlink" title="持久性：Durability"></a>持久性：Durability</h2><p>持久性要求，一个事务完成之后，事务的执行结果必须是持久话保存的。即使数据库发生崩溃，在数据库恢复后事务提交的结果仍然不会丢失。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>事务只能保证数据库的【<strong>高可靠性】</strong>，即数据库本身发生问题后，事务提交的数据仍然能恢复；而如果不是数据库本身的故障，如硬盘损坏了，那么事务提交的数据可能就丢失了。这属于<strong>【高可用性】</strong>的范畴。因此，事务只能保证数据库的<strong>【高可靠性】</strong>，而<strong>【高可用性】</strong>需要整个系统共同配合实现。</p>
<h1 id="3-事务的隔离级别"><a href="#3-事务的隔离级别" class="headerlink" title="3.事务的隔离级别"></a>3.事务的隔离级别</h1><p>在事务的四大特性ACID中，要求的隔离性是一种严格意义上的隔离，也就是多个事务是串行执行的，彼此之间不会收到任何干扰。这确实能够完全保证数据库的安全性，但在实际业务系统中，这种方式性能不高。因此，数据库定义了四种隔离级别，隔离级别和数据库的性能是呈反比的，隔离级别越低，数据库性能越高，而隔离级别越高，数据库性能越差。</p>
<h2 id="3-1事务并发执行会出现的问题"><a href="#3-1事务并发执行会出现的问题" class="headerlink" title="3.1事务并发执行会出现的问题"></a>3.1事务并发执行会出现的问题</h2><h3 id="3-1-1-更新丢失"><a href="#3-1-1-更新丢失" class="headerlink" title="3.1.1.更新丢失"></a>3.1.1.更新丢失</h3><p>当有两个并发执行的事务，更新同一行数据，那么有可能一个事务会把另一个事务的更新覆盖掉。当数据库没有加任何锁的情况下会发生。</p>
<h3 id="3-1-2脏读"><a href="#3-1-2脏读" class="headerlink" title="3.1.2脏读"></a>3.1.2脏读</h3><p>一个事务读到另一个尚未提交的事务中的数据。该数据可能会被回滚从而丢失。如果第一个事务拿着失效的数据去处理那就发生错误了。</p>
<h3 id="3-1-3-不可重复读"><a href="#3-1-3-不可重复读" class="headerlink" title="3.1.3.不可重复读"></a>3.1.3.不可重复读</h3><p>不可重复读的含义：一个事务对同一行数据读了两次，却得到了不同的结果。</p>
<ul>
<li><strong>虚读：</strong>在事务1两次读取同一记录的过程中，事务2对该记录进行了修改，从而事务1第二次读到了不一样的记录。</li>
<li><strong>幻读：</strong>事务1在两次查询的过程中，事务2对该表进行了插入、删除操作，从而事务1第二次查询的结果发生了变化。</li>
</ul>
<h2 id="3-2-不可重复读和脏读的区别？"><a href="#3-2-不可重复读和脏读的区别？" class="headerlink" title="3.2.不可重复读和脏读的区别？"></a>3.2.不可重复读和脏读的区别？</h2><p>脏读读到的是尚未提交的数据，而不可重复读读到的是已经提交的数据，只不过两次读的过程中数据被另一个事务修改过了。</p>
<h2 id="3-3-数据库的四种隔离级别"><a href="#3-3-数据库的四种隔离级别" class="headerlink" title="3.3.数据库的四种隔离级别"></a>3.3.数据库的四种隔离级别</h2><h3 id="3-3-1-未提交读：Read-uncommitted"><a href="#3-3-1-未提交读：Read-uncommitted" class="headerlink" title="3.3.1.未提交读：Read uncommitted"></a>3.3.1.未提交读：Read uncommitted</h3><p>在该级别下，一个事务对一行数据修改的过程中，不允许另一个事务对该数据进行修改，但允许另一个事务对该行数据读。因此本级别下，不会出现更新丢失，但会出现脏读、不可重复读。</p>
<h3 id="3-3-2-提交读：Read-committed"><a href="#3-3-2-提交读：Read-committed" class="headerlink" title="3.3.2.提交读：Read committed"></a>3.3.2.提交读：Read committed</h3><p>在该级别下，未提交的写事务不允许其他事务访问该行，因此不会出现脏读，但是读取数据的事务允许其他事务的访问该行数据，因此会出现不可重复读的情况。</p>
<h3 id="3-3-3-重复读：Repeatable-read"><a href="#3-3-3-重复读：Repeatable-read" class="headerlink" title="3.3.3.重复读：Repeatable read"></a>3.3.3.重复读：Repeatable read</h3><p>在该级别下，读事务禁止写事务，但允许读事务，因此不会出现同一事务两次读到不同的数据的情况（不可重复读），且写事务禁止其他一切事务。</p>
<h3 id="3-3-4-序列化：Serializable"><a href="#3-3-4-序列化：Serializable" class="headerlink" title="3.3.4.序列化：Serializable"></a>3.3.4.序列化：Serializable</h3><p>该级别要求所有事务都必须串行执行，因此能避免一切因并发引起的问题，但效率很低。</p>
<h2 id="3-4-注意"><a href="#3-4-注意" class="headerlink" title="3.4.注意"></a>3.4.注意</h2><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数程序，可以优先考虑把数据库系统的隔离级别设为<strong>【Read Committed】（提交读）</strong>，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读和第二类丢失更新这些并发问题，在可能出现这些问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p>
<h1 id="4-什么是分布式事务？"><a href="#4-什么是分布式事务？" class="headerlink" title="4.什么是分布式事务？"></a>4.什么是分布式事务？</h1><h2 id="4-1-CAP理论"><a href="#4-1-CAP理论" class="headerlink" title="4.1.CAP理论"></a>4.1.CAP理论</h2><p>CAP理论说的是：在一个分布式系统中，最多只能满足C、A、P中的两个需求<br>CAP的含义：<br>C：Consistency一致性，同一数据的多个副本是否实时相同<br>A：Availability可用性：一定时间内&amp;系统返回一个明确的结果则称为该系统可用。<br>P：Partition tolerance分区容错性，将同一服务分布在多个系统中，从而保证某一个系统宕机，仍然有其他系统提供相同的服务。<br>CAP理论告诉我们，在分布式系统中，C、A、P三个条件中我们最多只能选择两个。那么问题来了，究竟选择哪两个条件较为合适呢？</p>
<ul>
<li>对于一个业务系统来说，可用性和分区容错性是必须要满足的两个条件，并且这两者是相辅相成的。业务系统之所以使用分布式系统，主要原因有两个：</li>
<li>提升整体性能 当业务量猛增，单个服务器已经无法满足我们的业务需求的时候，就需要使用分布式系统，使用多个节点提供相同的功能，从而整体上提升系统的性能，这就是使用分布式系统的第一个原因。</li>
<li>实现分区容错性 单一节点 或 多个节点处于相同的网络环境下，那么会存在一定的风险，万一该机房断电、该地区发生自然灾害，那么业务系统就全面瘫痪了。为了防止这一问题，采用分布式系统，将多个子系统分布在不同的地域、不同的机房中，从而保证系统高可用性。</li>
</ul>
<p>这说明分区容错性是分布式系统的根本，如果分区容错性不能满足，那使用分布式系统将失去意义。<br>此外，可用性对业务系统也尤为重要。在大谈用户体验的今天，如果业务系统时常出现“系统异常”、响应时间过长等情况，这使得用户对系统的好感度大打折扣，在互联网行业竞争激烈的今天，相同领域的竞争者不甚枚举，系统的间歇性不可用会立马导致用户流向竞争对手。因此，我们只能通过牺牲一致性来换取系统的<strong>可用性</strong>和<strong>分区容错性</strong>。这也就是下面要介绍的BASE理论。</p>
<h2 id="4-2-BASE理论"><a href="#4-2-BASE理论" class="headerlink" title="4.2.BASE理论"></a>4.2.BASE理论</h2><p>CAP理论告诉我们一个悲惨但不得不接受的事实——我们只能在C、A、P中选择两个条件。而对于业务系统而言，我们往往选择牺牲一致性来换取系统的可用性和分区容错性。不过这里要指出的是，所谓的“牺牲一致性”并不是完全放弃数据一致性，而是牺牲<strong>强一致性</strong>换取<strong>弱一致性</strong>。下面来介绍下BASE理论。 </p>
<ul>
<li>BA：Basic Available 基本可用：整个系统在某些不可抗力的情况下，仍然能够保证“可用性”，即一定时间内仍然能够返回一个明确的结果。只不过“基本可用”和“高可用”的区别是： <ul>
<li>“一定时间”可以适当延长 当举行大促时，响应时间可以适当延长</li>
<li>给部分用户返回一个降级页面 给部分用户直接返回一个降级页面，从而缓解服务器压力。但要注意，返回降级页面仍然是返回明确结果。 </li>
</ul>
</li>
<li>S：Soft State：柔性状态 同一数据的不同副本的状态，可以不需要实时一致。</li>
<li>E：Eventual Consisstency：最终一致性 同一数据的不同副本的状态，可以不需要实时一致，但一定要保证经过一定时间后仍然是一致的。</li>
</ul>
<h1 id="5-酸碱平衡"><a href="#5-酸碱平衡" class="headerlink" title="5.酸碱平衡"></a>5.酸碱平衡</h1><p>ACID能够保证事务的强一致性，即数据的实时一致性。这在本地事务中是没有问题的，在分布式事务中，强一致性会极大影响分布式系统的性能，因此分布式系统遵循BASE理论极客。但分布式系统的不同业务场景对一致性的需求也不同。如交易场景下，就要求强一致性，此时就需要遵循ACID理论，而在注册成功后发送短信验证码等场景下，并不需要实时一致性，因此遵循BASE理论即可。因此需要根据具体业务场景，在ACID和BASE之间寻求平衡。</p>
<h1 id="6-分布式事务解决方案"><a href="#6-分布式事务解决方案" class="headerlink" title="6.分布式事务解决方案"></a>6.分布式事务解决方案</h1><h2 id="6-1-一阶段提交：弱XA"><a href="#6-1-一阶段提交：弱XA" class="headerlink" title="6.1.一阶段提交：弱XA"></a>6.1.一阶段提交：弱XA</h2><p>弱XA通过去掉XA的Prepare阶段，以达到减少资源锁定范围而提升并发性能的效果。典型的实现为在一个业务线程中，遍历所有的数据库连接，依次做commit或者rollback。弱XA同本地事务相比，性能损耗低，但在事务提交的执行过程中，若出现网络故障、数据库宕机等预期之外的异常，将会造成数据不一致，且无法进行回滚。基于弱XA的事务无需额外的实现成本，因此Sharding-Sphere默认支持。<br><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709220001.jpg" alt="图片"></p>
<h2 id="6-2-两阶段提交协议2PC"><a href="#6-2-两阶段提交协议2PC" class="headerlink" title="6.2.两阶段提交协议2PC"></a>6.2.两阶段提交协议2PC</h2><p>分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性。为实现这个目的，二阶段提交算法的成立基于一下假设：</p>
<ul>
<li>该分布式系统中，存在一个节点作为协调者（Coordinator），其他节点作为参与者（Cohorts），且节点之间可以进行网络通信。</li>
<li>所有节点都采用预写式日志，且日志被写入后台即保存在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li>
<li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li>
</ul>
<h3 id="6-1-1-第一阶段（投票阶段）"><a href="#6-1-1-第一阶段（投票阶段）" class="headerlink" title="6.1.1.第一阶段（投票阶段）"></a>6.1.1.第一阶段（投票阶段）</h3><ol>
<li>协调者节点向所有参与者节点询问是否可以执行提交操作（vote），并开始等待各参与者节点的响应。</li>
<li>参与者节点执行询问发起为止的所有事务操作，并将Undo信息和Redo信息写入日志。（注意：若成功这里其实每个参与者已经执行了事务操作）</li>
<li>各参与者节点响应协调者节点发起的询问。如果参与者节点的事务实际执行成功，则它返回一个“同意”消息；如果参与者节点的事务操作实际执行失败，则它返回一个“中止”消息。</li>
</ol>
<h3 id="6-1-2-（提交执行阶段）"><a href="#6-1-2-（提交执行阶段）" class="headerlink" title="6.1.2.（提交执行阶段）"></a>6.1.2.（提交执行阶段）</h3><p>当协调者节点从所有参与者节点获得的响应消息都为“同意”时：</p>
<ol>
<li>协调者节点向所有参与者节点发出“正式提交（commit）”的请求。</li>
<li>参与者节点正式完成操作，并释放在整个事务期间内占用的资源</li>
<li>参与者节点向协调者节点发送“完成”消息</li>
<li>协调者节点收到所有参与者节点反馈的“完成”消息，完成事务</li>
</ol>
<p>如果任一参与者节点在第一阶段返回的响应消息为“中止”，或者协调者节点在第一阶段的询问超时之前无法获取所有参与者节点的响应消息时：</p>
<ol>
<li>协调者节点向所有参与者节点发出“回滚操作（rollback）”的请求</li>
<li>参与者节点利用之前写入的Undo信息执行回滚，并释放在整个事务期间内占用的资源。</li>
<li>参与者节点向协调者节点发送“回滚完成”消息</li>
<li>协调者节点收到所有参与者节点反馈的“回滚完成”消息后，取消事务。</li>
</ol>
<p>不管最后结果如何，第二阶段都会结束当前事务。<br>二阶段提交看起来确实能够提供原子性的操作，但是不幸的是，二阶段提交还有几个缺点：</p>
<ol>
<li>执行过程中，所有参与者节点都是事务阻塞型的。当参与者占有公共资源时，其他第三方节点访问公共资源不得不处于阻塞状态。</li>
<li>参与者发生故障。协调者需要给所有参与者额外指定超时机制，超时后整个事务失败。（没有容错机制）</li>
<li>协调者发生故障。参与者会一直阻塞下去。需要额外的备份进行容错。</li>
<li>二阶段无法解决的问题：协调者再发出commit消息之后宕机，而唯一接收到这条消息的参与者同时也宕机了。那么即使协调者通过选举协议产生了新的协调者，这条事务的状态也是不确定的，每人知道事务是否已经被提交。</li>
<li>2PC模型中，在prepare阶段需要等待所有参与子事务的反馈，因此可能造成数据库资源锁定时间过长，不适合并发高以及子事务生命周期较长的业务场景。</li>
</ol>
<h2 id="6-3-三阶段提交协议3PC"><a href="#6-3-三阶段提交协议3PC" class="headerlink" title="6.3.三阶段提交协议3PC"></a>6.3.三阶段提交协议3PC</h2><p>与两阶段提交不同的是，三阶段提交有两个改动点。</p>
<ul>
<li>引入超时机制。同时在协调者和参与者中都引入超时机制</li>
<li>在第一阶段和第二阶段中插入一个准备阶段。保证了在最后提交阶段之前各参于节点的状态是一致的。</li>
</ul>
<p>也就是说，除了引入超时机制之外，3PC把2PC的准备阶段再次一分为二，这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。</p>
<h3 id="6-3-1-CanCommit阶段"><a href="#6-3-1-CanCommit阶段" class="headerlink" title="6.3.1.CanCommit阶段"></a>6.3.1.CanCommit阶段</h3><p>3PC的CanCommit阶段其实和2PC的准备阶段很像。协调者向参与者发送commit请求，参与者如果可以提交就返回yes响应，否则返回no响应。</p>
<ol>
<li>事务询问 协调者向参与者发送CanCommit请求。寻味是否可以执行事务提交操作。然后开始等待参与者的响应。</li>
<li>响应反馈 参与者接到CanCommit请求之后，正常情况下，如果自身认为可以顺利执行事务，则返回yes响应，并进入预备状态，否则返回no。</li>
</ol>
<h3 id="6-3-2-PreCommit阶段"><a href="#6-3-2-PreCommit阶段" class="headerlink" title="6.3.2.PreCommit阶段"></a>6.3.2.PreCommit阶段</h3><p>协调者根据参与者的反应情况来决定是否可以进行事务的PreCommit操作。根据响应情况，有以下两种可能。假如协调者从所有的参与者获得的返回都是Yes响应，那么就会执行事务的预执行。</p>
<ol>
<li>发送预提交请求 协调者向参与者发送PreCommit请求，并进入PreCommit阶段。</li>
<li>事务预提交 参与者接受到PreCommit请求后，会执行事务操作，并将Undo和Redo信息记录到事务日志中。</li>
<li>响应反馈 如果参与者成功的执行了事务操作，则返回ACK响应，同时开始等待最终指令。</li>
</ol>
<p>假如有任何一个参与者向协调者发送了No响应，或者等待超时之后，协调者都没有接到参与者的响应，那么就执行事务的中断。</p>
<ol>
<li>发送中断请求 协调者向所有参与者发送abort请求</li>
<li>中断事务 参与者收到来自协调者abort请求之后（或超时之后，仍未收到协调者的请求），执行事务的中断。</li>
</ol>
<h3 id="6-3-3-DoCommit阶段"><a href="#6-3-3-DoCommit阶段" class="headerlink" title="6.3.3.DoCommit阶段"></a>6.3.3.DoCommit阶段</h3><p>这个阶段进行真正的事务提交，也可以分为以下两种情况。<br><strong>6.3.3.1.执行提交</strong></p>
<ol>
<li>发送提交请求 协调者接受到参与者发送的ACK响应，那么他将从预提交状态进入到提交状态。并向所有参与者发送doCommit请求。</li>
<li>事务提交 参与者接受到doCommit请求之后，执行正式的事务提交，并在完成事务提交之后释放事务资源。</li>
<li>响应反馈 事务提交完之后，向协调者发送ACK响应</li>
<li>完成事务 协调者接受到所有参与者的ack响应之后，完成事务。</li>
</ol>
<p><strong>6.3.3.2.中断事务</strong><br>协调者没有接受到参与者发送的ACK响应（可能是接受者发送的不是ACK响应，也可能响应超时），那么就会执行中断事务。</p>
<ol>
<li>发送中断请求 协调者向所有参与者发送abort请求</li>
<li>事务回滚 参与者接受到abort请求之后，利用其在阶段二记录的undo信息来执行事务的回滚操作，并在完成回滚蛰藏释放所有的事务资源。</li>
<li>反馈结果 参与者完成事务回滚之后，向协调者发送ACK信息</li>
<li>中断事务 协调者接受到参与者反馈的ACK信息之后，执行事务的中断。</li>
</ol>
<h2 id="6-4-基于可靠消息服务的分布式事务"><a href="#6-4-基于可靠消息服务的分布式事务" class="headerlink" title="6.4.基于可靠消息服务的分布式事务"></a>6.4.基于可靠消息服务的分布式事务</h2><p>这种实现分布式事务的方式需要通过消息中间件来实现。假如有A和B两个系统，分别可以处理任务A和任务B。此时系统A中存在一个业务流程，需要将任务A和任务B在同一事务中处理。</p>
<h3 id="6-4-1-Commit"><a href="#6-4-1-Commit" class="headerlink" title="6.4.1.Commit"></a>6.4.1.Commit</h3><p><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709230002.jpg" alt="图片"></p>
<ol>
<li>在系统A处理任务A之前，首先向消息中间件发送一条消息。</li>
<li>消息中间件收到后将该条消息持久化，但并不投递。此时下游系统B仍然不知道该条消息的存在。</li>
<li>消息中间件持久化成功后，便向系统A返回一个确认回答</li>
<li>系统A收到确认回答后，则可以开始处理任务A；</li>
<li>任务A处理完成后，向消息中间件发送Commit请求。该请求发送完成后，对系统A而言，该事务的处理过程就结束了，此时它可以处理别的事务。但Commit消息可能会在传输途中丢失，从而消息中间件并不会向系统B投递这条消息，从而系统就会出现不一致性。这个问题由消息中间件的事务回查机制来完成</li>
<li>消息中间件收到commit指令后，便向系统B投递该消息，从而触发任务B的执行。</li>
<li>当任务B执行完成后，系统B向消息中间件返回一个确认回答，告诉消息中间件该消息已经成功消费，此时，这个分布式事务完成。</li>
</ol>
<p><strong>结论：</strong></p>
<ol>
<li>消息中间件扮演着分布式事务协调者的角色。</li>
<li>系统A完成任务A之后，到任务B执行完成之间，会存在一定的时间差。在这个时间差内，整个系统处于数据不一致的状态，但这短暂的不一致性是可以接受的，因为经过短暂的时间后，系统又昆虫保持数据一致性，满足BASE理论。</li>
</ol>
<h3 id="6-4-2-Rollback"><a href="#6-4-2-Rollback" class="headerlink" title="6.4.2.Rollback"></a>6.4.2.Rollback</h3><p>如果任务A执行失败，那么需要进入到回滚流程，如下图所示：<br><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709230003.jpg" alt="图片"></p>
<ol>
<li>若系统A在处理任务A时失败，那么就会向消息中间件发送RollBack请求。和发送Commit请求一样，系统A发完之后便可以任务回滚已经完成，它便可以去做其他的事情。</li>
<li>消息中间件收到回滚请求后，直接将该消息丢弃，而不投递给系统B，从而不会触发系统B的任务B。（此时系统又处于一致性状态，因为任务A和任务B都没有执行）</li>
</ol>
<h3 id="6-4-3-超时询问机制"><a href="#6-4-3-超时询问机制" class="headerlink" title="6.4.3.超时询问机制"></a>6.4.3.超时询问机制</h3><p>上面的commit和rollback都属于理想情况，但在实际系统中，Commit和Rollback指令都可能在传输途中丢失。在这种情况下通过超时询问机制保证数据的一致性。<br><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709240001.jpg" alt="图片"><br>系统A除了实现正常的业务流程外，还需提供一个事务询问的接口，该消息中间件调用。当消息中间件收到一条事务型消息后便开始计时，如果到了超时时间也没收到系统A发来的commit或rollback指令的话，就会主动调用系统A提供的事务询问接口询问该系统目前的状态，该接口会返回三种结果：</p>
<ul>
<li>提交 若获得的状态是“提交”，则将该消息投递给系统B</li>
<li>回滚 若获得的状态是“回滚”，则直接将该条消息丢弃。</li>
<li>处理中 若获得的状态是“处理中”，则继续等待。<blockquote>
<p>消息中间件的超时询问机制能够防止上游系统因在传输过程中丢失commit/rollback指令而导致的系统不一致情况，而且能降低上游系统的阻塞时间，上游系统只要发出commit/rollback指令后便可以处理其他任务，无需等待确认回答。而commit/rollback指令丢失的情况通过超时询问机制来弥补，这样大大降低了上游系统的阻塞时间，提升系统的并发度。</p>
</blockquote>
</li>
</ul>
<h3 id="6-4-4-消息投递过程的可靠性保证"><a href="#6-4-4-消息投递过程的可靠性保证" class="headerlink" title="6.4.4.消息投递过程的可靠性保证"></a>6.4.4.消息投递过程的可靠性保证</h3><p>当上游系统执行完任务并向消息中间件提交了commit指令后，便可以处理其他任务了，此时它可以任务事务已经完成，接下来消息中间件一定保证消息被下游系统成功消费掉。（具体如何实现是基于消息中间件的投递流程来保证）</p>
<ul>
<li>消息中间件向下游系统投递消息后便进入阻塞等待状态，下游系统便立即进行任务的处理，任务处理完成后便向消息中间件返回应答。消息中间件收到确认应答后便任务该事务处理完毕！</li>
<li>如果消息在投递过程中丢失，或确认的消息应答在返回途中丢失，那么消息中中间件在等待确认应答超时之后就会重新投递，直到下游消费者返回消费成功响应为止。当然，一般消息中间件可以设置消息重试的次数和时间间隔，比如：当第一次投递失败后，每隔五分钟重试一次，一共重试三次，如果重试三次张总仍然投递失败，那么这条消息就需要人工干预。</li>
<li><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709240002.jpg" alt="图片"></li>
<li><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709250001.jpg" alt="图片"></li>
</ul>
<p><strong>消息投递失败后为什么不回滚消息，而是不断尝试重新投递？</strong><br>这涉及到整套分布式事务系统的实现成本问题。我们知道，当系统A将向消息中间件发送Commit指令后，它便去做别的事情了，如果此时消息投递失败，需要回滚的话，就需要让系统A首先提供回滚接口，这无疑增加了额外的开发成本，业务系统的复杂度也将提高，对于一个业务系统的设计目标是，在保证性能的前提下，最大限度地降低系统复杂度，从而能够降低系统的运维成本。</p>
<p><strong>上游系统A向消息中间件提交Commit/Rollback消息采用的是异步方式，也就是当上游系统提交完消息后便可以去做别的事情，接下来提交、回滚就完全交给消息中间件来完成，并且完全信任消息中间件，认为它一定能正确地完成事务的提交或回滚。然而，消息中间件向下游系统投递消息的过程是同步的。也就是消息中间件将消息投递给下游系统后，它会阻塞等待，等下游系统成功处理完任务返回确认应答后才取消阻塞等待。为什么这两者在设计上是不一致的呢？</strong><br>首先，上游系统和消息中间件之间采用异步通信是为了提高系统并发度。业务系统直接和用户打交道，用户体验尤为重要，因此这种异步通信方式能够极大程度地降低用户等待时间。此外，异步通信相对于同步通信而言，没有了长时间的阻塞等待，因此系统的并发性也大大增加。但异步通信可能会引起Commit/Rollback指令丢失的问题，这就由消息中间件的超时询问机制来弥补。</p>
<p><strong>那么，消息中间件和下游系统之间为什么要采用同步通信呢？</strong><br>异步能提升系统性能，但随之会增加系统复杂度；而同步虽然降低系统并发度，但实现成本较低。因此，在对并发度要求不是很高的情况下，或者服务器资源较为充裕的情况下，我们可以选择同步来降低系统的复杂度。 我们知道，消息中间件是一个独立于业务系统的第三方中间件，它不和任何业务系统产生直接的耦合，它也不和用户产生直接的关联，它一般部署在独立的服务器集群上，具有良好的可扩展性，所以不必太过于担心它的性能，如果处理速度无法满足我们的要求，可以增加机器来解决。而且，即使消息中间件处理速度有一定的延迟那也是可以接受的，因为前面所介绍的BASE理论就告诉我们了，我们追求的是最终一致性，而非实时一致性，因此消息中间件产生的时延导致事务短暂的不一致是可以接受的。</p>
<h2 id="6-5-最大努力通知"><a href="#6-5-最大努力通知" class="headerlink" title="6.5.最大努力通知"></a>6.5.最大努力通知</h2><p>最大努力通知也被称为定期校对，其实在方案二中已经包含，这里再单独介绍，主要是为了知识体系的完整性。这种方案也需要消息中间件的参与，其过程如下：<br><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709250002.jpg" alt="图片"></p>
<ul>
<li>上游系统在完成任务后，向消息中间件同步地发送一条消息，确保消息中间件成功持久化这条消息，然后上游系统可以去做别的事情了；</li>
<li>消息中间件收到消息后负责将该消息同步投递给相应的下游系统，并触发下游系统的任务执行；</li>
<li>当下游系统处理成功后，向消息中间件反馈确认应答，消息中间件便可以将该条消息删除，从而该事务完成。</li>
</ul>
<p>上面是一个理想化的过程，但在实际场景中，往往会出现如下几种意外情况：</p>
<ol>
<li>消息中间件向下游系统投递消息失败</li>
<li>上游系统向消息中间件发送消息失败</li>
</ol>
<p>对于第一种情况，消息中间件具有重试机制，我们可以在消息中间件中设置消息的重试次数和重试时间间隔，对于网络不稳定导致的消息投递失败的情况，往往重试几次后消息便可以成功投递，如果超过了重试的上限仍然投递失败，那么消息中间件不再投递该消息，而是记录在失败消息表中，消息中间件需要提供失败消息的查询接口，下游系统会定期查询失败消息，并将其消费，这就是所谓的“定期校对”。</p>
<p>如果重复投递和定期校对都不能解决问题，往往是因为下游系统出现了严重的错误，此时就需要人工干预。</p>
<p>对于第二种情况，需要在上游系统中建立消息重发机制。可以在上游系统建立一张本地消息表，并将 <strong>任务处理过程</strong> 和 <strong>向本地消息表中插入消息</strong> 这两个步骤放在一个本地事务中完成。如果向本地消息表插入消息失败，那么就会触发回滚，之前的任务处理结果就会被取消。如果这两步都执行成功，那么该本地事务就完成了。接下来会有一个专门的消息发送者不断地发送本地消息表中的消息，如果发送失败它会返回重试。当然，也要给消息发送者设置重试的上限，一般而言，达到重试上限仍然发送失败，那就意味着消息中间件出现严重的问题，此时也只有人工干预才能解决问题。</p>
<p>对于不支持事务型消息的消息中间件，如果要实现分布式事务的话，就可以采用这种方式。它能够通过<strong>重试机制</strong>+<strong>定期校对</strong>实现分布式事务，但相比于第二种方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制，以确保消息成功发布给消息中间件，这无疑增加了业务系统的开发成本，使得业务系统不够纯粹，并且这些额外的业务逻辑无疑会占用业务系统的硬件资源，从而影响性能。</p>
<p>因此，尽量选择支持事务型消息的消息中间件来实现分布式事务，如RocketMQ。</p>
<h2 id="6-6-TCC（两阶段型、补偿型）"><a href="#6-6-TCC（两阶段型、补偿型）" class="headerlink" title="6.6.TCC（两阶段型、补偿型）"></a>6.6.TCC（两阶段型、补偿型）</h2><p>TCC即为Try Confirm Cancel，它属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p>
<ul>
<li>**Try：尝试待执行的业务 **<ul>
<li>这个过程并未执行业务，只是完成所有业务的一致性检查，并预留好执行所需的全部资源</li>
</ul>
</li>
<li><strong>Confirm：执行业务</strong><ul>
<li>这个过程真正开始执行业务，由于Try阶段已经完成了一致性检查，因此本过程直接执行，而不做任何检查。并且在执行的过程中，会使用到Try阶段预留的业务资源。</li>
</ul>
</li>
<li><strong>Cancel：取消执行的业务</strong><ul>
<li>若业务执行失败，则进入Cancel阶段，它会释放所有占用的业务资源，并回滚Confirm阶段执行的操作。</li>
</ul>
</li>
</ul>
<p>在传统事务机制中，业务逻辑的执行和事务的处理，是在不同的阶段由不同的部件来完成的：业务逻辑部分访问资源实现数据存储，其处理是由业务系统负责；事务处理部分通过协调资源管理器以实现事务管理，其处理由事务管理器来负责。二者没有太多交互的地方，所以，传统事务管理器的事务处理逻辑，仅需要着眼于事务完成（commit/rollback）阶段，而不必关注业务执行阶段。</p>
<h3 id="6-6-1-TCC全局事务必须基于RM本地事务来实现全局事务"><a href="#6-6-1-TCC全局事务必须基于RM本地事务来实现全局事务" class="headerlink" title="6.6.1.TCC全局事务必须基于RM本地事务来实现全局事务"></a>6.6.1.TCC全局事务必须基于RM本地事务来实现全局事务</h3><p>TCC服务是由Try/Confirm/Cancel业务构成的， 其Try/Confirm/Cancel业务在执行时，会访问资源管理器（Resource Manager，下文简称RM）来存取数据。这些存取操作，必须要参与RM本地事务，以使其更改的数据要么都commit，要么都rollback。<br><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709250003.jpg" alt="图片"><br>假设图中的服务B没有基于RM本地事务（以RDBS为例，可通过设置auto-commit为true来模拟），那么一旦[B:Try]操作中途执行失败，TCC事务框架后续决定回滚全局事务时，该[B:Cancel]则需要判断[B:Try]中哪些操作已经写到DB、哪些操作还没有写到DB：假设[B:Try]业务有5个写库操作，[B:Cancel]业务则需要逐个判断这5个操作是否生效，并将生效的操作执行反向操作。</p>
<p>不幸的是，由于[B:Cancel]业务也有n（0&lt;=n&lt;=5）个反向的写库操作，此时一旦[B:Cancel]也中途出错，则后续的[B:Cancel]执行任务更加繁重。因为，相比第一次[B:Cancel]操作，后续的[B:Cancel]操作还需要判断先前的[B:Cancel]操作的n（0&lt;=n&lt;=5）个写库中哪几个已经执行、哪几个还没有执行，这就涉及到了幂等性问题。而对幂等性的保障，又很可能还需要涉及额外的写库操作，该写库操作又会因为没有RM本地事务的支持而存在类似问题。。。可想而知，如果不基于RM本地事务，TCC事务框架是无法有效的管理TCC全局事务的。</p>
<p>反之，基于RM本地事务的TCC事务，这种情况则会很容易处理：[B:Try]操作中途执行失败，TCC事务框架将其参与RM本地事务直接rollback即可。后续TCC事务框架决定回滚全局事务时，在知道“[B:Try]操作涉及的RM本地事务已经rollback”的情况下，根本无需执行[B:Cancel]操作。</p>
<p>换句话说，基于RM本地事务实现TCC事务框架时，一个TCC型服务的cancel业务要么执行，要么不执行，不需要考虑部分执行的情况。</p>
<h3 id="6-6-2-TCC事务框架应该提供Confirm-Cancel服务的幂等性保障"><a href="#6-6-2-TCC事务框架应该提供Confirm-Cancel服务的幂等性保障" class="headerlink" title="6.6.2.TCC事务框架应该提供Confirm/Cancel服务的幂等性保障"></a>6.6.2.TCC事务框架应该提供Confirm/Cancel服务的幂等性保障</h3><p>一般认为，服务的幂等性，是指针对同一个服务的多次(n&gt;1)请求和对它的单次(n=1)请求，二者具有相同的副作用。</p>
<p>在TCC事务模型中，Confirm/Cancel业务可能会被重复调用，其原因很多。比如，全局事务在提交/回滚时会调用各TCC服务的Confirm/Cancel业务逻辑。执行这些Confirm/Cancel业务时，可能会出现如网络中断的故障而使得全局事务不能完成。因此，故障恢复机制后续仍然会重新提交/回滚这些未完成的全局事务，这样就会再次调用参与该全局事务的各TCC服务的Confirm/Cancel业务逻辑。</p>
<p>既然Confirm/Cancel业务可能会被多次调用，就需要保障其幂等性。 那么，应该由TCC事务框架来提供幂等性保障？还是应该由业务系统自行来保障幂等性呢？ 个人认为，应该是由TCC事务框架来提供幂等性保障。如果仅仅只是极个别服务存在这个问题的话，那么由业务系统来负责也是可以的；然而，这是一类公共问题，毫无疑问，所有TCC服务的Confirm/Cancel业务存在幂等性问题。TCC服务的公共问题应该由TCC事务框架来解决；而且，考虑一下由业务系统来负责幂等性需要考虑的问题，就会发现，这无疑增大了业务系统的复杂度。</p>
<h3 id="6-6-3示例"><a href="#6-6-3示例" class="headerlink" title="6.6.3示例"></a>6.6.3示例</h3><p><img src="/images/%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/2019031709260001.jpg" alt="图片"></p>
<h2 id="6-7-Saga"><a href="#6-7-Saga" class="headerlink" title="6.7.Saga"></a>6.7.Saga</h2><p>Saga模型将一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模块和补偿模块（TCC中的Comfirm和Cancel）。当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务的最终一致性。<br>当每个Saga子事务T1, T2, …, Tn都有对应补偿协议 C1, C2, …, Cn-1,那么Saga系统可以保证：</p>
<ul>
<li>子事务序列T1, T2, …, Tn得以完成（最佳情况）；</li>
<li>或者序列T1, T2, …, Tj, Cj, …, C2, C1, 0 &lt; j &lt; n, 得以完成。</li>
</ul>
<p>犹豫saga模型没有Prepare阶段，因此事务间不能保证隔离性，当多个Saga事务操作同一资源时，就会发生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：</p>
<ul>
<li>在应用层面加锁</li>
<li>应用层面预先冻结资源</li>
</ul>
<p>Saga恢复方式<br>Saga支持向前和向后恢复：</p>
<ul>
<li>向后恢复：补偿所有已完成的事务，如果任一子事务失败；</li>
<li>向前恢复：重试失败的事务，假设每个子事务最终都会成功。</li>
</ul>
<p>显然，向前恢复没有必要提供补偿事务吗，如果你得事务中，子事务（最终）总会成功，或补偿事务难以定义或不可能，向前恢复更符合你的需求。，理论上补偿事务永不失败，然而，在分布式世界中，服务器可能会宕机、网络可能会失败，甚至数据中心也可能会停电，这时需要提供故障恢复后回退的机制，比如人工干预。</p>
<h2 id="6-8-几种方式的总结"><a href="#6-8-几种方式的总结" class="headerlink" title="6.8.几种方式的总结"></a>6.8.几种方式的总结</h2><p>TCC、MQ都是以服务为范围进行分布式事务的处理，而XA、BED、SAGA则是以数据库为范围进行分布式处理，我们更趋向于选择后者，对于业务而言侵入小，改造的成本低。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/java/" rel="tag"># java</a>
              <a href="/tags/springboot/" rel="tag"># springboot</a>
              <a href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/" rel="tag"># 分布式事务</a>
              <a href="/tags/%E4%BA%8B%E5%8A%A1/" rel="tag"># 事务</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/03/14/%E9%98%85%E8%AF%BB%E7%AF%87/%E5%B7%B2%E8%AF%BB/%E3%80%8A%E5%8D%81%E4%B9%9D%E9%97%B4%E6%88%BF%E3%80%8B_%E8%8B%8F%E7%AB%A5/" rel="prev" title="《十九间房》_苏童">
      <i class="fa fa-chevron-left"></i> 《十九间房》_苏童
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/03/16/%E6%8A%80%E8%83%BD%E7%AF%87/java/spring/springboot/%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E6%A0%A1%E9%AA%8C/" rel="next" title="springboot集成swagger2">
      springboot集成swagger2 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">1.</span> <span class="nav-text">1.什么是事务？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7ACID"><span class="nav-number">2.</span> <span class="nav-text">2.事务的四大特性ACID</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8E%9F%E5%AD%90%E6%80%A7%EF%BC%9AAtomicity"><span class="nav-number">2.1.</span> <span class="nav-text">原子性：Atomicity</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E8%87%B4%E6%80%A7%EF%BC%9AConsistency"><span class="nav-number">2.2.</span> <span class="nav-text">一致性：Consistency</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%9AIsolation"><span class="nav-number">2.3.</span> <span class="nav-text">隔离性：Isolation</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8C%81%E4%B9%85%E6%80%A7%EF%BC%9ADurability"><span class="nav-number">2.4.</span> <span class="nav-text">持久性：Durability</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">2.5.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.</span> <span class="nav-text">3.事务的隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1%E4%BA%8B%E5%8A%A1%E5%B9%B6%E5%8F%91%E6%89%A7%E8%A1%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">3.1.</span> <span class="nav-text">3.1事务并发执行会出现的问题</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-%E6%9B%B4%E6%96%B0%E4%B8%A2%E5%A4%B1"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1.更新丢失</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2%E8%84%8F%E8%AF%BB"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2脏读</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3.不可重复读</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E8%84%8F%E8%AF%BB%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="nav-number">3.2.</span> <span class="nav-text">3.2.不可重复读和脏读的区别？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%9B%9B%E7%A7%8D%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">3.3.</span> <span class="nav-text">3.3.数据库的四种隔离级别</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-%E6%9C%AA%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%9ARead-uncommitted"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1.未提交读：Read uncommitted</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-%E6%8F%90%E4%BA%A4%E8%AF%BB%EF%BC%9ARead-committed"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2.提交读：Read committed</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-%E9%87%8D%E5%A4%8D%E8%AF%BB%EF%BC%9ARepeatable-read"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3.重复读：Repeatable read</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9ASerializable"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4.序列化：Serializable</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-%E6%B3%A8%E6%84%8F"><span class="nav-number">3.4.</span> <span class="nav-text">3.4.注意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-%E4%BB%80%E4%B9%88%E6%98%AF%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%EF%BC%9F"><span class="nav-number">4.</span> <span class="nav-text">4.什么是分布式事务？</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-CAP%E7%90%86%E8%AE%BA"><span class="nav-number">4.1.</span> <span class="nav-text">4.1.CAP理论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-BASE%E7%90%86%E8%AE%BA"><span class="nav-number">4.2.</span> <span class="nav-text">4.2.BASE理论</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-%E9%85%B8%E7%A2%B1%E5%B9%B3%E8%A1%A1"><span class="nav-number">5.</span> <span class="nav-text">5.酸碱平衡</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="nav-number">6.</span> <span class="nav-text">6.分布式事务解决方案</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-%E4%B8%80%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%EF%BC%9A%E5%BC%B1XA"><span class="nav-number">6.1.</span> <span class="nav-text">6.1.一阶段提交：弱XA</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE2PC"><span class="nav-number">6.2.</span> <span class="nav-text">6.2.两阶段提交协议2PC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%EF%BC%88%E6%8A%95%E7%A5%A8%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.1.1.第一阶段（投票阶段）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-%EF%BC%88%E6%8F%90%E4%BA%A4%E6%89%A7%E8%A1%8C%E9%98%B6%E6%AE%B5%EF%BC%89"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.1.2.（提交执行阶段）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-%E4%B8%89%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4%E5%8D%8F%E8%AE%AE3PC"><span class="nav-number">6.3.</span> <span class="nav-text">6.3.三阶段提交协议3PC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-CanCommit%E9%98%B6%E6%AE%B5"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1.CanCommit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-PreCommit%E9%98%B6%E6%AE%B5"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2.PreCommit阶段</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-DoCommit%E9%98%B6%E6%AE%B5"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3.DoCommit阶段</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-%E5%9F%BA%E4%BA%8E%E5%8F%AF%E9%9D%A0%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.4.</span> <span class="nav-text">6.4.基于可靠消息服务的分布式事务</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-Commit"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1.Commit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-Rollback"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2.Rollback</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-3-%E8%B6%85%E6%97%B6%E8%AF%A2%E9%97%AE%E6%9C%BA%E5%88%B6"><span class="nav-number">6.4.3.</span> <span class="nav-text">6.4.3.超时询问机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-4-%E6%B6%88%E6%81%AF%E6%8A%95%E9%80%92%E8%BF%87%E7%A8%8B%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81"><span class="nav-number">6.4.4.</span> <span class="nav-text">6.4.4.消息投递过程的可靠性保证</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5"><span class="nav-number">6.5.</span> <span class="nav-text">6.5.最大努力通知</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-TCC%EF%BC%88%E4%B8%A4%E9%98%B6%E6%AE%B5%E5%9E%8B%E3%80%81%E8%A1%A5%E5%81%BF%E5%9E%8B%EF%BC%89"><span class="nav-number">6.6.</span> <span class="nav-text">6.6.TCC（两阶段型、补偿型）</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-TCC%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1%E5%BF%85%E9%A1%BB%E5%9F%BA%E4%BA%8ERM%E6%9C%AC%E5%9C%B0%E4%BA%8B%E5%8A%A1%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E4%BA%8B%E5%8A%A1"><span class="nav-number">6.6.1.</span> <span class="nav-text">6.6.1.TCC全局事务必须基于RM本地事务来实现全局事务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-TCC%E4%BA%8B%E5%8A%A1%E6%A1%86%E6%9E%B6%E5%BA%94%E8%AF%A5%E6%8F%90%E4%BE%9BConfirm-Cancel%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%B9%82%E7%AD%89%E6%80%A7%E4%BF%9D%E9%9A%9C"><span class="nav-number">6.6.2.</span> <span class="nav-text">6.6.2.TCC事务框架应该提供Confirm&#x2F;Cancel服务的幂等性保障</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3%E7%A4%BA%E4%BE%8B"><span class="nav-number">6.6.3.</span> <span class="nav-text">6.6.3示例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-Saga"><span class="nav-number">6.7.</span> <span class="nav-text">6.7.Saga</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-8-%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%E7%9A%84%E6%80%BB%E7%BB%93"><span class="nav-number">6.8.</span> <span class="nav-text">6.8.几种方式的总结</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">不登山峰，不显平地</p>
  <div class="site-description" itemprop="description">木鱼者，相传云，鱼昼夜常醒，刻木像形击之，所以警昏情也。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">368</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">34</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lark-coder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lark-coder" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不登山峰，不显平地</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">750k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">11:21</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
