<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.hudi.tech","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="《java并发编程的艺术》的阅读摘录">
<meta property="og:type" content="article">
<meta property="og:title" content="《java并发编程的艺术》">
<meta property="og:url" content="http://www.hudi.tech/2019/04/14/%E9%98%85%E8%AF%BB%E7%AF%87/%E6%8A%80%E6%9C%AF/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B/index.html">
<meta property="og:site_name" content="木刻的鱼儿的博客">
<meta property="og:description" content="《java并发编程的艺术》的阅读摘录">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2019-04-13T16:00:00.000Z">
<meta property="article:modified_time" content="2020-09-05T14:50:18.617Z">
<meta property="article:author" content="不登山峰，不显平地">
<meta property="article:tag" content="阅读">
<meta property="article:tag" content="技术">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.hudi.tech/2019/04/14/%E9%98%85%E8%AF%BB%E7%AF%87/%E6%8A%80%E6%9C%AF/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>《java并发编程的艺术》 | 木刻的鱼儿的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>



<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">木刻的鱼儿的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.hudi.tech/2019/04/14/%E9%98%85%E8%AF%BB%E7%AF%87/%E6%8A%80%E6%9C%AF/%E3%80%8Ajava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF%E3%80%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="不登山峰，不显平地">
      <meta itemprop="description" content="木鱼者，相传云，鱼昼夜常醒，刻木像形击之，所以警昏情也。">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="木刻的鱼儿的博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          《java并发编程的艺术》
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-04-14 00:00:00" itemprop="dateCreated datePublished" datetime="2019-04-14T00:00:00+08:00">2019-04-14</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-09-05 22:50:18" itemprop="dateModified" datetime="2020-09-05T22:50:18+08:00">2020-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB%E7%AF%87/" itemprop="url" rel="index"><span itemprop="name">阅读篇</span></a>
                </span>
                  ，
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%98%85%E8%AF%BB%E7%AF%87/%E6%8A%80%E6%9C%AF/" itemprop="url" rel="index"><span itemprop="name">技术</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>34k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>31 分钟</span>
            </span>
            <div class="post-description">《java并发编程的艺术》的阅读摘录</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="摘录"><a href="#摘录" class="headerlink" title="摘录"></a>摘录</h1><h2 id="1-《并发编程的挑战》"><a href="#1-《并发编程的挑战》" class="headerlink" title="1.《并发编程的挑战》"></a>1.《并发编程的挑战》</h2><h3 id="1-1《上下文切换》"><a href="#1-1《上下文切换》" class="headerlink" title="1.1《上下文切换》"></a>1.1《上下文切换》</h3><ul>
<li>即使是单核处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。</li>
<li>任务从保存到再加载的过程就是一次上下文切换。</li>
<li>当并发执行累加操作不超过百万次时，速度会比串行执行累加操作要慢。那么，为什么并发执行的速度会比串行慢呢？这是因为线程有创建和上下文切换的开销。</li>
<li>使用Lmbench可以测量上下文切换的时长。使用vmstat可以测量上下文切换的次数。</li>
<li>减少上下文切换的方法有无锁并发编程、CAS算法、使用最少线程和使用协程。<ul>
<li>无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
<li>CAS算法。Java的Atomic包使用CAS算法来更新数据，而不需要加锁。</li>
<li>使用最少线程。避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li>
<li>协程：在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li>
</ul>
</li>
</ul>
<h3 id="1-2《死锁》"><a href="#1-2《死锁》" class="headerlink" title="1.2《死锁》"></a>1.2《死锁》</h3><ul>
<li>避免死锁的几个常见方法。<ul>
<li>避免一个线程同时获取多个锁。</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源。</li>
<li>尝试使用定时锁，使用lock.tryLock（timeout）来替代使用内部锁机制。</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
</li>
</ul>
<h3 id="1-3《资源限制的挑战》"><a href="#1-3《资源限制的挑战》" class="headerlink" title="1.3《资源限制的挑战》"></a>1.3《资源限制的挑战》</h3><ul>
<li>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。</li>
<li>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="2-《Java并发机制的底层实现原理》"><a href="#2-《Java并发机制的底层实现原理》" class="headerlink" title="2.《Java并发机制的底层实现原理》"></a>2.《Java并发机制的底层实现原理》</h2><h3 id="2-1《volatile的应用》"><a href="#2-1《volatile的应用》" class="headerlink" title="2.1《volatile的应用》"></a>2.1《volatile的应用》</h3><ul>
<li>volatile是轻量级的synchronized，它在多处理器开发中保证了共享变量的“可见性”。可见性的意思是当一个线程修改一个共享变量时，另外一个线程能读到这个修改的值。</li>
<li>volatile比synchronized的使用和执行成本更低，因为它不会引起线程上下文的切换和调度。</li>
<li>Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致地更新，线程应该确保通过排他锁单独获得这个变量。Java语言提供了volatile，在某些情况下比锁要更加方便。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</li>
<li>Lock前缀指令会引起处理器缓存回写到内存。Lock前缀指令导致在执行指令期间，声言处理器的LOCK#信号。在多处理器环境中，LOCK#信号确保在声言该信号期间，处理器可以独占任何共享内存。</li>
</ul>
<h3 id="2-2《synchronized的实现原理与应用》"><a href="#2-2《synchronized的实现原理与应用》" class="headerlink" title="2.2《synchronized的实现原理与应用》"></a>2.2《synchronized的实现原理与应用》</h3><ul>
<li>利用synchronized实现同步的基础：Java中的每一个对象都可以作为锁。具体表现为以下3种形式。<ul>
<li>对于普通同步方法，锁是当前实例对象。</li>
<li>对于静态同步方法，锁是当前类的Class对象。</li>
<li>对于同步方法块，锁是Synchonized括号里配置的对象。</li>
</ul>
</li>
<li>从JVM规范中可以看到Synchonized在JVM里的实现原理，JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，细节在JVM规范里并没有详细说明。但是，方法的同步同样可以使用这两个指令来实现。</li>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。</li>
</ul>
<h4 id="2-2-1《Java对象头》"><a href="#2-2-1《Java对象头》" class="headerlink" title="2.2.1《Java对象头》"></a>2.2.1《Java对象头》</h4><ul>
<li>synchronized用的锁是存在Java对象头里的。</li>
</ul>
<h4 id="2-2-2《锁的升级与对比》"><a href="#2-2-2《锁的升级与对比》" class="headerlink" title="2.2.2《锁的升级与对比》"></a>2.2.2《锁的升级与对比》</h4><ul>
<li>在Java SE 1.6中，锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。</li>
<li>【偏向锁的添加】大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。当一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否存储着指向当前线程的偏向锁。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）：如果没有设置，则使用CAS竞争锁；如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
<li>【偏向锁的撤销】偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）。它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要么重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。</li>
<li>【关闭偏向锁】偏向锁在Java 6和Java 7里是默认启用的，但是它在应用程序启动几秒钟之后才激活，如有必要可以使用JVM参数来关闭延迟：-XX:BiasedLockingStartupDelay=0。如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-UseBiasedLocking=false，那么程序默认会进入轻量级锁状态。</li>
<li>【轻量锁加锁】线程在执行同步块之前，JVM会先在当前线程的栈桢中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中，官方称为Displaced Mark Word。然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁。</li>
<li>【轻量级锁解锁】轻量级解锁时，会使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。</li>
<li>因为自旋会消耗CPU，为了避免无用的自旋（比如获得锁的线程被阻塞住了），一旦锁升级成重量级锁，就不会再恢复到轻量级锁状态。当锁处于这个状态下，其他线程试图获取锁时，都会被阻塞住，当持有锁的线程释放锁之后会唤醒这些线程，被唤醒的线程就会进行新一轮的夺锁之争。</li>
</ul>
<h3 id="2-3《原子操作的实现原理》"><a href="#2-3《原子操作的实现原理》" class="headerlink" title="2.3《原子操作的实现原理》"></a>2.3《原子操作的实现原理》</h3><ul>
<li>第一个机制是通过总线锁保证原子性。所谓总线锁就是使用处理器提供的一个LOCK #信号，当一个处理器在总线上输出此信号时，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</li>
<li>第二个机制是通过缓存锁定来保证原子性。所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声言LOCK #信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据，当其他处理器回写已被锁定的缓存行的数据时，会使缓存行无效，在如图2-3所示的例子中，当CPU1修改缓存行中的i时使用了缓存锁定，那么CPU2就不能同时缓存i的缓存行。<ul>
<li>但是有两种情况下处理器不会使用缓存锁定。</li>
<li>第一种情况是：当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行（cache line）时，则处理器会调用总线锁定。</li>
<li>第二种情况是：有些处理器不支持缓存锁定。对于Intel 486和Pentium处理器，就算锁定的内存区域在处理器的缓存行中也会调用总线锁定。</li>
</ul>
</li>
<li>Java如何实现原子操作<ul>
<li>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止</li>
<li>CAS实现原子操作的三大问题<ul>
<li>ABA问题。ABA问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加1，那么A→B→A就会变成1A→2B→3A。</li>
<li>循环时间长开销大。自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。如果JVM能支持处理器提供的pause指令，那么效率会有一定的提升。pause指令有两个作用：第一，它可以延迟流水线执行指令（de-pipeline），使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零；第二，它可以避免在退出循环的时候因内存顺序冲突（Memory Order Violation）而引起CPU流水线被清空（CPU Pipeline Flush），从而提高CPU的执行效率。</li>
<li>只能保证一个共享变量的原子操作。当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i=2,j=a，合并一下ij=2a，然后用CAS来操作ij。</li>
</ul>
</li>
<li>使用锁机制实现原子操作。锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。JVM内部实现了很多种锁机制，有偏向锁、轻量级锁和互斥锁。有意思的是除了偏向锁，JVM实现锁的方式都用了循环CAS，即当一个线程想进入同步块的时候使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>
</ul>
</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="3-《Java内存模型》"><a href="#3-《Java内存模型》" class="headerlink" title="3.《Java内存模型》"></a>3.《Java内存模型》</h2><h3 id="3-1《java内存模型的基础》"><a href="#3-1《java内存模型的基础》" class="headerlink" title="3.1《java内存模型的基础》"></a>3.1《java内存模型的基础》</h3><h4 id="3-1-1《并发编程模型的两个关键问题》"><a href="#3-1-1《并发编程模型的两个关键问题》" class="headerlink" title="3.1.1《并发编程模型的两个关键问题》"></a>3.1.1《并发编程模型的两个关键问题》</h4><ul>
<li>在并发编程中，需要处理两个关键问题：线程之间如何通信及线程之间如何同步（这里的线程是指并发执行的活动实体）。通信是指线程之间以何种机制来交换信息。</li>
<li>在共享内存的并发模型里，线程之间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里，线程之间没有公共状态，线程之间必须通过发送消息来显式进行通信。</li>
<li>同步是指程序中用于控制不同线程间操作发生相对顺序的机制。在共享内存并发模型里，同步是显式进行的。程序员必须显式指定某个方法或某段代码需要在线程之间互斥执行。在消息传递的并发模型里，由于消息的发送必须在消息的接收之前，因此同步是隐式进行的。</li>
<li>Java的并发采用的是共享内存模型，Java线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</li>
</ul>
<h4 id="3-1-2《Java内存模型的抽象结构》"><a href="#3-1-2《Java内存模型的抽象结构》" class="headerlink" title="3.1.2《Java内存模型的抽象结构》"></a>3.1.2《Java内存模型的抽象结构》</h4><ul>
<li>在Java中，所有实例域、静态域和数组元素都存储在堆内存中，堆内存在线程之间共享。局部变量（Local Variables），方法定义参数（Java语言规范称之为Formal Method Parameters）和异常处理器参数（Exception Handler Parameters）不会在线程之间共享，它们不会有内存可见性问题，也不受内存模型的影响。</li>
<li>Java线程之间的通信由Java内存模型（本文简称为JMM）控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（Main Memory）中，每个线程都有一个私有的本地内存（Local Memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器以及其他的硬件和编译器优化。</li>
</ul>
<h4 id="3-1-3《从源代码到指令序列的重排序》"><a href="#3-1-3《从源代码到指令序列的重排序》" class="headerlink" title="3.1.3《从源代码到指令序列的重排序》"></a>3.1.3《从源代码到指令序列的重排序》</h4><ul>
<li>重排序分3种类型。<ul>
<li>1）编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li>
<li>2）指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism，ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li>
<li>3）内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
</li>
<li>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台之上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</li>
</ul>
<h4 id="3-1-4《并发编程模型的分类》"><a href="#3-1-4《并发编程模型的分类》" class="headerlink" title="3.1.4《并发编程模型的分类》"></a>3.1.4《并发编程模型的分类》</h4><ul>
<li>现代的处理器使用写缓冲区临时保存向内存写入的数据。写缓冲区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟。</li>
</ul>
<h4 id="3-1-5《happens-before简介》"><a href="#3-1-5《happens-before简介》" class="headerlink" title="3.1.5《happens-before简介》"></a>3.1.5《happens-before简介》</h4><ul>
<li>happens-before规则如下：<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens- before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
</ul>
</li>
</ul>
<h3 id="3-2《重排序》"><a href="#3-2《重排序》" class="headerlink" title="3.2《重排序》"></a>3.2《重排序》</h3><h4 id="3-2-1《数据依赖性》"><a href="#3-2-1《数据依赖性》" class="headerlink" title="3.2.1《数据依赖性》"></a>3.2.1《数据依赖性》</h4><ul>
<li>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性。</li>
<li>这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</li>
</ul>
<h4 id="3-2-2《as-if-serial语义》"><a href="#3-2-2《as-if-serial语义》" class="headerlink" title="3.2.2《as-if-serial语义》"></a>3.2.2《as-if-serial语义》</h4><ul>
<li>as-if-serial语义的意思是：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。</li>
<li>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重排序。</li>
</ul>
<h4 id="3-2-3《程序顺序规则》"><a href="#3-2-3《程序顺序规则》" class="headerlink" title="3.2.3《程序顺序规则》"></a>3.2.3《程序顺序规则》</h4><ul>
<li>如果A happens-before B，JMM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。这里操作A的执行结果不需要对操作B可见；而且重排序操作A和操作B后的执行结果，与操作A和操作B按happens- before顺序执行的结果一致。在这种情况下，JMM会认为这种重排序并不非法（not illegal），JMM允许这种重排序。</li>
</ul>
<h4 id="3-2-4《重排序对多线程的影响》"><a href="#3-2-4《重排序对多线程的影响》" class="headerlink" title="3.2.4《重排序对多线程的影响》"></a>3.2.4《重排序对多线程的影响》</h4><h3 id="3-3《顺序一致性》"><a href="#3-3《顺序一致性》" class="headerlink" title="3.3《顺序一致性》"></a>3.3《顺序一致性》</h3><ul>
<li>顺序一致性内存模型是一个理论参考模型，在设计的时候，处理器的内存模型和编程语言的内存模型都会以顺序一致性内存模型作为参照。</li>
</ul>
<h4 id="3-3-1《数据竞争与顺序一致性》"><a href="#3-3-1《数据竞争与顺序一致性》" class="headerlink" title="3.3.1《数据竞争与顺序一致性》"></a>3.3.1《数据竞争与顺序一致性》</h4><ul>
<li>Java内存模型规范对数据竞争的定义如下：在一个线程中写一个变量，在另一个线程读同一个变量，而且写和读没有通过同步来排序。</li>
</ul>
<h4 id="3-3-2《顺序一致性内存模型》"><a href="#3-3-2《顺序一致性内存模型》" class="headerlink" title="3.3.2《顺序一致性内存模型》"></a>3.3.2《顺序一致性内存模型》</h4><ul>
<li>顺序一致性内存模型有两大特性：<ul>
<li>1）一个线程中的所有操作必须按照程序的顺序来执行。</li>
<li>2）（不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
</li>
<li>未同步程序在顺序一致性模型中虽然整体执行顺序是无序的，但所有线程都只能看到一个一致的整体执行顺序。以上图为例，线程A和B看到的执行顺序都是：B1→A1→A2→B2→A3→B3。之所以能得到这个保证是因为顺序一致性内存模型中的每个操作必须立即对任意线程可见。但是，在JMM中就没有这个保证。未同步程序在JMM中不但整体的执行顺序是无序的，而且所有线程看到的操作执行顺序也可能不一致。</li>
</ul>
<h4 id="3-3-3《同步程序的顺序一致性效果》"><a href="#3-3-3《同步程序的顺序一致性效果》" class="headerlink" title="3.3.3《同步程序的顺序一致性效果》"></a>3.3.3《同步程序的顺序一致性效果》</h4><ul>
<li>在JMM中，临界区内的代码可以重排序（但JMM不允许临界区内的代码“逸出”到临界区之外，那样会破坏监视器的语义）。JMM会在退出临界区和进入临界区这两个关键时间点做一些特别处理，使得线程在这两个时间点具有与顺序一致性模型相同的内存视图（具体细节后文会说明）。虽然线程A在临界区内做了重排序，但由于监视器互斥执行的特性，这里的线程B根本无法“观察”到线程A在临界区内的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</li>
<li>JMM在具体实现上的基本方针为：在不改变（正确同步的）程序执行结果的前提下，尽可能地为编译器和处理器的优化打开方便之门。</li>
</ul>
<h4 id="3-3-4《未同步程序的执行特性》"><a href="#3-3-4《未同步程序的执行特性》" class="headerlink" title="3.3.4《未同步程序的执行特性》"></a>3.3.4《未同步程序的执行特性》</h4><ul>
<li>对于未同步或未正确同步的多线程程序，JMM只提供最小安全性：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0，Null，False），JMM保证线程读操作读取到的值不会无中生有（Out Of Thin Air）的冒出来。为了实现最小安全性，JVM在堆上分配对象时，首先会对内存空间进行清零，然后才会在上面分配对象（JVM内部会同步这两个操作）。因此，在已清零的内存空间（Pre-zeroed Memory）分配对象时，域的默认初始化已经完成了。</li>
<li>未同步程序在两个模型中的执行特性有如下几个差异：<ul>
<li>1）顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前面已经讲过了，这里就不再赘述。</li>
<li>2）顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。这一点前面也已经讲过，这里就不再赘述。</li>
<li>3）JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。</li>
</ul>
</li>
</ul>
<h3 id="3-4《volatile的内存语义》"><a href="#3-4《volatile的内存语义》" class="headerlink" title="3.4《volatile的内存语义》"></a>3.4《volatile的内存语义》</h3><h4 id="3-4-1《volatile的特性》"><a href="#3-4-1《volatile的特性》" class="headerlink" title="3.4.1《volatile的特性》"></a>3.4.1《volatile的特性》</h4><ul>
<li>一个volatile变量的单个读/写操作，与一个普通变量的读/写操作都是使用同一个锁来同步，它们之间的执行效果相同。</li>
<li>锁的happens-before规则保证释放锁和获取锁的两个线程之间的内存可见性，这意味着对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>锁的语义决定了临界区代码的执行具有原子性。这意味着，即使是64位的long型和double型变量，只要它是volatile变量，对该变量的读/写就具有原子性。如果是多个volatile操作或类似于volatile++这种复合操作，这些操作整体上不具有原子性。</li>
<li>volatile变量自身具有下列特性：<ul>
<li>可见性。对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种复合操作不具有原子性。</li>
</ul>
</li>
</ul>
<h4 id="3-4-2《volatile写-读建立的happens-before关系》"><a href="#3-4-2《volatile写-读建立的happens-before关系》" class="headerlink" title="3.4.2《volatile写-读建立的happens-before关系》"></a>3.4.2《volatile写-读建立的happens-before关系》</h4><h4 id="3-4-3《volatile写-读的内存语义》"><a href="#3-4-3《volatile写-读的内存语义》" class="headerlink" title="3.4.3《volatile写-读的内存语义》"></a>3.4.3《volatile写-读的内存语义》</h4><ul>
<li>volatile写的内存语义如下：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存。</li>
<li>volatile读的内存语义如下：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
</ul>
<h4 id="3-4-4《volatile内存语义的实现》"><a href="#3-4-4《volatile内存语义的实现》" class="headerlink" title="3.4.4《volatile内存语义的实现》"></a>3.4.4《volatile内存语义的实现》</h4><ul>
<li>前文提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。</li>
<li>第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。</li>
<li>第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。</li>
<li>当第一个操作是volatile写，第二个操作是volatile读时，不能重排序。</li>
<li>因为volatile写-读内存语义的常见使用模式是：一个写线程写volatile变量，多个读线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。</li>
<li>JMM在实现上的一个特点：首先确保正确性，然后再去追求执行效率。</li>
</ul>
<h4 id="3-4-5《JSR-133为什么要增强volatile的内存语义》"><a href="#3-4-5《JSR-133为什么要增强volatile的内存语义》" class="headerlink" title="3.4.5《JSR-133为什么要增强volatile的内存语义》"></a>3.4.5《JSR-133为什么要增强volatile的内存语义》</h4><ul>
<li>JSR-133专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序，确保volatile的写-读和锁的释放-获取具有相同的内存语义。</li>
<li>在功能上，锁比volatile更强大；在可伸缩性和执行性能上，volatile更有优势。</li>
</ul>
<h3 id="3-5《锁的内存语义》"><a href="#3-5《锁的内存语义》" class="headerlink" title="3.5《锁的内存语义》"></a>3.5《锁的内存语义》</h3><p>《锁的释放-获取建立的happens-before关系》</p>
<ul>
<li>锁是Java并发编程中最重要的同步机制。锁除了让临界区互斥执行外，还可以让释放锁的线程向获取同一个锁的线程发送消息。</li>
</ul>
<h4 id="3-5-1《锁的释放和获取的内存语义》"><a href="#3-5-1《锁的释放和获取的内存语义》" class="headerlink" title="3.5.1《锁的释放和获取的内存语义》"></a>3.5.1《锁的释放和获取的内存语义》</h4><ul>
<li>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。</li>
<li>锁释放与volatile写有相同的内存语义；锁获取与volatile读有相同的内存语义。</li>
<li>对锁释放和锁获取的内存语义做个总结：<ul>
<li>线程A释放一个锁，实质上是线程A向接下来将要获取这个锁的某个线程发出了（线程A对共享变量所做修改的）消息。</li>
<li>线程B获取一个锁，实质上是线程B接收了之前某个线程发出的（在释放这个锁之前对共享变量所做修改的）消息。</li>
<li>线程A释放锁，随后线程B获取这个锁，这个过程实质上是线程A通过主内存向线程B发送消息。</li>
</ul>
</li>
</ul>
<h4 id="3-5-2《锁内存语义的实现》"><a href="#3-5-2《锁内存语义的实现》" class="headerlink" title="3.5.2《锁内存语义的实现》"></a>3.5.2《锁内存语义的实现》</h4><ul>
<li>ReentrantLock的实现依赖于Java同步器框架AbstractQueuedSynchronizer（本文简称之为AQS）。AQS使用一个整型的volatile变量（命名为state）来维护同步状态，马上我们会看到，这个volatile变量是ReentrantLock内存语义实现的关键。</li>
<li>公平锁<ul>
<li>加锁方法首先读volatile变量state。在释放锁的最后写volatile变量state。</li>
<li>公平锁在释放锁的最后写volatile变量state，在获取锁时首先读这个volatile变量。根据volatile的happens-before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</li>
</ul>
</li>
<li>非公平锁<ul>
<li>本文把Java的compareAndSet()方法调用简称为CAS。JDK文档对该方法的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。</li>
<li>程序会根据当前处理器的类型来决定是否为cmpxchg指令添加lock前缀。如果程序是在多处理器上运行，就为cmpxchg指令加上lock前缀（Lock Cmpxchg）。反之，如果程序是在单处理器上运行，就省略lock前缀（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障效果）。</li>
</ul>
</li>
<li>对公平锁和非公平锁的内存语义做个总结：<ul>
<li>公平锁和非公平锁释放时，最后都要写一个volatile变量state。</li>
<li>公平锁获取时，首先会去读volatile变量。</li>
<li>非公平锁获取时，首先会用CAS更新volatile变量，这个操作同时具有volatile读和volatile写的内存语义。</li>
</ul>
</li>
<li>锁释放-获取的内存语义的实现至少有下面两种方式。<ul>
<li>利用volatile变量的写-读所具有的内存语义。</li>
<li>利用CAS所附带的volatile读和volatile写的内存语义。</li>
</ul>
</li>
</ul>
<h4 id="3-5-3《concurrent包的实现》"><a href="#3-5-3《concurrent包的实现》" class="headerlink" title="3.5.3《concurrent包的实现》"></a>3.5.3《concurrent包的实现》</h4><ul>
<li>由于Java的CAS同时具有volatile读和volatile写的内存语义，因此Java线程之间的通信现在有了下面4种方式。<ul>
<li>A线程写volatile变量，随后B线程读这个volatile变量。</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。</li>
<li>A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。</li>
</ul>
</li>
<li>通过concurrent包的源代码实现，会发现一个通用化的实现模式：<ul>
<li>首先，声明共享变量为volatile。</li>
<li>然后，使用CAS的原子条件更新来实现线程之间的同步。</li>
<li>同时，配合以volatile的读/写和CAS所具有的volatile读和写的内存语义来实现线程之间的通信。</li>
</ul>
</li>
<li>AQS，非阻塞数据结构和原子变量类（java.util.concurrent.atomic包中的类），这些concurrent包中的基础类都是使用这种模式来实现的，而concurrent包中的高层类又是依赖于这些基础类来实现的。</li>
</ul>
<h3 id="3-6《final域的内存语义》"><a href="#3-6《final域的内存语义》" class="headerlink" title="3.6《final域的内存语义》"></a>3.6《final域的内存语义》</h3><h4 id="3-6-1《final域的重排序规则》"><a href="#3-6-1《final域的重排序规则》" class="headerlink" title="3.6.1《final域的重排序规则》"></a>3.6.1《final域的重排序规则》</h4><ul>
<li>对于final域，编译器和处理器要遵守两个重排序规则：<ul>
<li>1）在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ul>
</li>
</ul>
<h4 id="3-6-2《写final域的重排序规则》"><a href="#3-6-2《写final域的重排序规则》" class="headerlink" title="3.6.2《写final域的重排序规则》"></a>3.6.2《写final域的重排序规则》</h4><ul>
<li>写final域的重排序规则禁止把final域的写重排序到构造函数之外。这个规则的实现包含下面2个方面：<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外。</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
</li>
<li>在对象引用为任意线程可见之前，对象的final域已经被正确初始化过了，而普通域不具有这个保障。</li>
</ul>
<h4 id="3-6-3《读final域的重排序规则》"><a href="#3-6-3《读final域的重排序规则》" class="headerlink" title="3.6.3《读final域的重排序规则》"></a>3.6.3《读final域的重排序规则》</h4><ul>
<li>读final域的重排序规则是，在一个线程中，初次读对象引用与初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final域操作的前面插入一个LoadLoad屏障。</li>
<li>初次读对象引用与初次读该对象包含的final域，这两个操作之间存在间接依赖关系。由于编译器遵守间接依赖关系，因此编译器不会重排序这两个操作。大多数处理器也会遵守间接依赖，也不会重排序这两个操作。</li>
<li>读final域的重排序规则可以确保：在读一个对象的final域之前，一定会先读包含这个final域的对象的引用。在这个示例程序中，如果该引用不为null，那么引用对象的final域一定已经被A线程初始化过了。</li>
</ul>
<h4 id="3-6-4《final域为引用类型》"><a href="#3-6-4《final域为引用类型》" class="headerlink" title="3.6.4《final域为引用类型》"></a>3.6.4《final域为引用类型》</h4><ul>
<li>对于引用类型，写final域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</li>
</ul>
<h4 id="3-6-5《为什么final引用不能从构造函数内“溢出”》"><a href="#3-6-5《为什么final引用不能从构造函数内“溢出”》" class="headerlink" title="3.6.5《为什么final引用不能从构造函数内“溢出”》"></a>3.6.5《为什么final引用不能从构造函数内“溢出”》</h4><ul>
<li>写final域的重排序规则可以确保：在引用变量为任意线程可见之前，该引用变量指向的对象的final域已经在构造函数中被正确初始化过了。其实，要得到这个效果，还需要一个保证：在构造函数内部，不能让这个被构造对象的引用为其他线程所见，也就是对象引用不能在构造函数中“逸出”。</li>
<li>在构造函数返回前，被构造对象的引用不能为其他线程所见，因为此时的final域可能还没有被初始化。在构造函数返回后，任意线程都将保证能看到final域正确初始化之后的值。</li>
</ul>
<h4 id="3-6-6《final语义在处理器中的实现》"><a href="#3-6-6《final语义在处理器中的实现》" class="headerlink" title="3.6.6《final语义在处理器中的实现》"></a>3.6.6《final语义在处理器中的实现》</h4><p>《JSR-133为什么要增强final的语义》</p>
<ul>
<li>通过为final域增加写和读重排序规则，可以为Java程序员提供初始化安全保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</li>
</ul>
<h3 id="3-7《happens-before》"><a href="#3-7《happens-before》" class="headerlink" title="3.7《happens-before》"></a>3.7《happens-before》</h3><h4 id="3-7-1《JMM的设计》"><a href="#3-7-1《JMM的设计》" class="headerlink" title="3.7.1《JMM的设计》"></a>3.7.1《JMM的设计》</h4><ul>
<li>在设计JMM时，需要考虑两个关键因素：<ul>
<li>程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于一个强内存模型来编写代码。</li>
<li>编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模型。</li>
</ul>
</li>
<li>设计JMM时的核心目标就是找到一个好的平衡点：一方面，要为程序员提供足够强的内存可见性保证；另一方面，对编译器和处理器的限制要尽可能地放松。</li>
<li>JMM把happens-before要求禁止的重排序分为了下面两类：<ul>
<li>会改变程序执行结果的重排序。</li>
<li>不会改变程序执行结果的重排序。</li>
</ul>
</li>
<li>JMM对这两种不同性质的重排序，采取了不同的策略，如下：<ul>
<li>对于会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。</li>
<li>对于不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。</li>
</ul>
</li>
</ul>
<h4 id="3-7-2《happens-before的定义》"><a href="#3-7-2《happens-before的定义》" class="headerlink" title="3.7.2《happens-before的定义》"></a>3.7.2《happens-before的定义》</h4><ul>
<li>对happens-before关系的定义如下：<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，JMM允许这种重排序）。</li>
</ul>
</li>
<li>JMM其实是在遵循一个基本原则：只要不改变程序的执行结果（指的是单线程程序和正确同步的多线程程序），编译器和处理器怎么优化都行。JMM这么做的原因是：程序员对于这两个操作是否真的被重排序并不关心，程序员关心的是程序执行时的语义不能被改变（即执行结果不能被改变）。</li>
<li>happens-before关系本质上和as-if-serial语义是一回事<ul>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。</li>
<li>as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序来执行的。happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li>
</ul>
</li>
<li>as-if-serial语义和happens-before这么做的目的，都是为了在不改变程序执行结果的前提下，尽可能地提高程序执行的并行度。</li>
</ul>
<h4 id="3-7-3《happens-before规则》"><a href="#3-7-3《happens-before规则》" class="headerlink" title="3.7.3《happens-before规则》"></a>3.7.3《happens-before规则》</h4><ul>
<li>happens-before规则：<ul>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>join()规则：如果线程A执行操作ThreadB. join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB. join()操作成功返回。<h3 id="3-8《双重检查锁定与延迟初始化》"><a href="#3-8《双重检查锁定与延迟初始化》" class="headerlink" title="3.8《双重检查锁定与延迟初始化》"></a>3.8《双重检查锁定与延迟初始化》</h3></li>
</ul>
</li>
<li>在Java多线程程序中，有时候需要采用延迟初始化来降低初始化类和创建对象的开销。双重检查锁定是常见的延迟初始化技术，但它是一个错误的用法。本文将分析双重检查锁定的错误根源，以及两种线程安全的延迟初始化方案。</li>
</ul>
<h4 id="3-8-1《双重检查锁定的由来》"><a href="#3-8-1《双重检查锁定的由来》" class="headerlink" title="3.8.1《双重检查锁定的由来》"></a>3.8.1《双重检查锁定的由来》</h4><ul>
<li>在Java程序中，有时候可能需要推迟一些高开销的对象初始化操作，并且只有在使用这些对象时才进行初始化。此时，程序员可能会采用延迟初始化。</li>
<li>多个线程试图在同一时间创建对象时，会通过加锁来保证只有一个线程能创建对象。</li>
<li>在对象创建好之后，执行getInstance()方法将不需要获取锁，直接返回已创建好的对象。</li>
</ul>
<h4 id="3-8-2《问题的根源》"><a href="#3-8-2《问题的根源》" class="headerlink" title="3.8.2《问题的根源》"></a>3.8.2《问题的根源》</h4><h4 id="3-8-3《基于volatile的解决方案》"><a href="#3-8-3《基于volatile的解决方案》" class="headerlink" title="3.8.3《基于volatile的解决方案》"></a>3.8.3《基于volatile的解决方案》</h4><h4 id="3-8-4《基于类初始化的解决方案》"><a href="#3-8-4《基于类初始化的解决方案》" class="headerlink" title="3.8.4《基于类初始化的解决方案》"></a>3.8.4《基于类初始化的解决方案》</h4><ul>
<li>JVM在类的初始化阶段（即在Class被加载后，且被线程使用之前），会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化。</li>
<li>Java语言规范规定，对于每一个类或接口C，都有一个唯一的初始化锁LC与之对应。从C到LC的映射，由JVM的具体实现去自由实现。JVM在类初始化期间会获取这个初始化锁，并且每个线程至少获取一次锁来确保这个类已经被初始化过了。</li>
<li>对于类或接口的初始化，Java语言规范制定了精巧而复杂的类初始化处理过程：<ul>
<li>第1阶段：通过在Class对象上同步（即获取Class对象的初始化锁），来控制类或接口的初始化。这个获取锁的线程会一直等待，直到当前线程能够获取到这个初始化锁。</li>
<li>第2阶段：线程A执行类的初始化，同时线程B在初始化锁对应的condition上等待。</li>
<li>第3阶段：线程A设置state=initialized，然后唤醒在condition中等待的所有线程。</li>
<li>第4阶段：线程B结束类的初始化处理。</li>
<li>第5阶段：线程C执行类的初始化的处理。</li>
</ul>
</li>
</ul>
<h3 id="3-9《Java内存模型综述》"><a href="#3-9《Java内存模型综述》" class="headerlink" title="3.9《Java内存模型综述》"></a>3.9《Java内存模型综述》</h3><h4 id="3-9-1《处理器的内存模型》"><a href="#3-9-1《处理器的内存模型》" class="headerlink" title="3.9.1《处理器的内存模型》"></a>3.9.1《处理器的内存模型》</h4><ul>
<li>根据对不同类型的读/写操作组合的执行顺序的放松，可以把常见处理器的内存模型划分为如下几种类型：<ul>
<li>放松程序中写-读操作的顺序，由此产生了Total Store Ordering内存模型（简称为TSO）。</li>
<li>在上面的基础上，继续放松程序中写-写操作的顺序，由此产生了Partial Store Order内存模型（简称为PSO）。</li>
<li>在前面两条的基础上，继续放松程序中读-写和读-读操作的顺序，由此产生了Relaxed Memory Order内存模型（简称为RMO）和PowerPC内存模型。</li>
</ul>
</li>
</ul>
<h4 id="3-9-2《各种内存模型之间的关系》"><a href="#3-9-2《各种内存模型之间的关系》" class="headerlink" title="3.9.2《各种内存模型之间的关系》"></a>3.9.2《各种内存模型之间的关系》</h4><ul>
<li>常见的4种处理器内存模型比常用的3中语言内存模型要弱，处理器内存模型和语言内存模型都比顺序一致性内存模型要弱。同处理器内存模型一样，越是追求执行性能的语言，内存模型设计得会越弱。</li>
</ul>
<h4 id="3-9-3《JMM的内存可见性保证》"><a href="#3-9-3《JMM的内存可见性保证》" class="headerlink" title="3.9.3《JMM的内存可见性保证》"></a>3.9.3《JMM的内存可见性保证》</h4><ul>
<li>Java程序的内存可见性保证可以分为下列3类：<ul>
<li>单线程程序。单线程程序不会出现内存可见性问题。编译器、runtime和处理器会共同确保单线程程序的执行结果与该程序在顺序一致性模型中的执行结果相同。</li>
<li>正确同步的多线程程序。正确同步的多线程程序的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是JMM关注的重点，JMM通过限制编译器和处理器的重排序来为程序员提供内存可见性保证。</li>
<li>未同步/未正确同步的多线程程序。JMM为它们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。</li>
</ul>
</li>
<li>最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值（0、null、false）。但最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。</li>
<li>只要多线程程序是正确同步的，JMM保证该程序在任意的处理器平台上的执行结果，与该程序在顺序一致性内存模型中的执行结果一致。</li>
</ul>
<h4 id="3-9-4《JSR-133对旧内存模型的修补》"><a href="#3-9-4《JSR-133对旧内存模型的修补》" class="headerlink" title="3.9.4《JSR-133对旧内存模型的修补》"></a>3.9.4《JSR-133对旧内存模型的修补》</h4><ul>
<li>增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。JSR-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和锁的释放-获取具有相同的内存语义。</li>
<li>增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，JSR-133为final增加了两个重排序规则。在保证final引用不会从构造函数内逸出的情况下，final具有了初始化安全性。</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="4-《Java并发编程基础》"><a href="#4-《Java并发编程基础》" class="headerlink" title="4.《Java并发编程基础》"></a>4.《Java并发编程基础》</h2><ul>
<li>线程作为操作系统调度的最小单元，多个线程能够同时执行，这将显著提升程序性能，在多核环境中表现得更加明显。但是，过多地创建线程和对线程的不当管理也容易造成问题。<h3 id="4-1-《线程简介》"><a href="#4-1-《线程简介》" class="headerlink" title="4.1.《线程简介》"></a>4.1.《线程简介》</h3><h4 id="4-1-1《什么是线程》"><a href="#4-1-1《什么是线程》" class="headerlink" title="4.1.1《什么是线程》"></a>4.1.1《什么是线程》</h4></li>
<li>现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。现代操作系统调度的最小单元是线程，也叫轻量级进程（Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换，让使用者感觉到这些线程在同时执行。</li>
<li>一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。</li>
</ul>
<h4 id="4-1-2《为什么要使用多线程》"><a href="#4-1-2《为什么要使用多线程》" class="headerlink" title="4.1.2《为什么要使用多线程》"></a>4.1.2《为什么要使用多线程》</h4><ul>
<li>使用多线程的原因主要有以下几点：<ul>
<li>更多的处理器核心。线程是大多数操作系统调度的基本单元，一个程序作为一个进程来运行，程序运行过程中能够创建多个线程，而一个线程在一个时刻只能运行在一个处理器核心上。</li>
<li>更快的响应时间。</li>
<li>更好的编程模型。</li>
</ul>
</li>
</ul>
<h4 id="4-1-3《线程优先级》"><a href="#4-1-3《线程优先级》" class="headerlink" title="4.1.3《线程优先级》"></a>4.1.3《线程优先级》</h4><ul>
<li>现代操作系统基本采用时分的形式调度运行的线程，操作系统会分出一个个时间片，线程会分配到若干时间片，当线程的时间片用完了就会发生线程调度，并等待着下次分配。线程分配到的时间片多少也就决定了线程使用处理器资源的多少，而线程优先级就是决定线程需要多或者少分配一些处理器资源的线程属性。</li>
<li>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1～10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</li>
<li>线程优先级不能作为程序正确性的依赖，因为操作系统可以完全不用理会Java线程对于优先级的设定。</li>
</ul>
<h4 id="4-1-4《线程的状态》"><a href="#4-1-4《线程的状态》" class="headerlink" title="4.1.4《线程的状态》"></a>4.1.4《线程的状态》</h4><ul>
<li>线程创建之后，调用start()方法开始运行。当线程执行wait()方法之后，线程进入等待状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，也就是超时时间到达时将会返回到运行状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到阻塞状态。线程在执行Runnable的run()方法之后将会进入到终止状态。</li>
<li>Java将操作系统中的运行和就绪两个状态合并称为运行状态。阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块（获取锁）时的状态，但是阻塞在java. concurrent包中Lock接口的线程状态却是等待状态，因为java.concurrent包中Lock接口对于阻塞的实现均使用了LockSupport类中的相关方法。</li>
</ul>
<h4 id="4-1-5《Daemon线程》"><a href="#4-1-5《Daemon线程》" class="headerlink" title="4.1.5《Daemon线程》"></a>4.1.5《Daemon线程》</h4><ul>
<li>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。</li>
<li>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置。</li>
<li>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</li>
</ul>
<h3 id="4-2《启动和终止线程》"><a href="#4-2《启动和终止线程》" class="headerlink" title="4.2《启动和终止线程》"></a>4.2《启动和终止线程》</h3><h4 id="4-2-1《构造线程》"><a href="#4-2-1《构造线程》" class="headerlink" title="4.2.1《构造线程》"></a>4.2.1《构造线程》</h4><ul>
<li>在运行线程之前首先要构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息。</li>
<li>一个新构造的线程对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。至此，一个能够运行的线程对象就初始化好了，在堆内存中等待着运行。</li>
</ul>
<h4 id="4-2-2《启动线程》"><a href="#4-2-2《启动线程》" class="headerlink" title="4.2.2《启动线程》"></a>4.2.2《启动线程》</h4><ul>
<li>线程对象在初始化完成之后，调用start()方法就可以启动这个线程。线程start()方法的含义是：当前线程（即parent线程）同步告知Java虚拟机，只要线程规划器空闲，应立即启动调用start()方法的线程。</li>
<li>启动一个线程前，最好为这个线程设置线程名称，因为这样在使用jstack分析程序或者进行问题排查时，就会给开发人员提供一些提示，自定义的线程最好能够起个名字。</li>
</ul>
<h4 id="4-2-3《理解中断》"><a href="#4-2-3《理解中断》" class="headerlink" title="4.2.3《理解中断》"></a>4.2.3《理解中断》</h4><ul>
<li>中断可以理解为线程的一个标识位属性，它表示一个运行中的线程是否被其他线程进行了中断操作。中断好比其他线程对该线程打了个招呼，其他线程通过调用该线程的interrupt()方法对其进行中断操作。</li>
<li>。</li>
<li>线程通过检查自身是否被中断来进行响应，线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，即使该线程被中断过，在调用该线程对象的isInterrupted()时依旧会返回false。</li>
</ul>
<h4 id="4-2-4《过期的suspend-、resume-和stop-》"><a href="#4-2-4《过期的suspend-、resume-和stop-》" class="headerlink" title="4.2.4《过期的suspend()、resume()和stop()》"></a>4.2.4《过期的suspend()、resume()和stop()》</h4><ul>
<li>以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</li>
</ul>
<h4 id="4-2-5《安全地终止线程》"><a href="#4-2-5《安全地终止线程》" class="headerlink" title="4.2.5《安全地终止线程》"></a>4.2.5《安全地终止线程》</h4><ul>
<li>中断状态是线程的一个标识位，而中断操作是一种简便的线程间交互方式，而这种交互方式最适合用来取消或停止任务。除了中断以外，还可以利用一个boolean变量来控制是否需要停止任务并终止该线程。</li>
</ul>
<h3 id="4-3《线程间通信》"><a href="#4-3《线程间通信》" class="headerlink" title="4.3《线程间通信》"></a>4.3《线程间通信》</h3><h4 id="4-3-1《volatile和synchronized关键字》"><a href="#4-3-1《volatile和synchronized关键字》" class="headerlink" title="4.3.1《volatile和synchronized关键字》"></a>4.3.1《volatile和synchronized关键字》</h4><ul>
<li>Java支持多个线程同时访问一个对象或者对象的成员变量，由于每个线程可以拥有这个变量的拷贝（虽然对象以及成员变量分配的内存是在共享内存中的，但是每个执行的线程还是可以拥有一份拷贝，这样做的目的是加速程序的执行，这是现代多核处理器的一个显著特性），所以程序在执行过程中，一个线程看到的变量并不一定是最新的。</li>
<li>关键字volatile可以用来修饰字段（成员变量），就是告知程序任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。</li>
<li>过多地使用volatile是不必要的，因为它会降低程序执行的效率。</li>
<li>关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性。</li>
<li>其本质是对一个对象的监视器（monitor）进行获取，而这个获取过程是排他的，也就是同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。</li>
<li>任意一个对象都拥有自己的监视器，当这个对象由同步块或者这个对象的同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器（执行该方法）的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCKED状态。</li>
<li>任意线程对Object（Object由synchronized保护）的访问，首先要获得Object的监视器。如果获取失败，线程进入同步队列，线程状态变为BLOCKED。当访问Object的前驱（获得了锁的线程）释放了锁，则该释放操作唤醒阻塞在同步队列中的线程，使其重新尝试对监视器的获取。</li>
</ul>
<h4 id="4-3-2《等待-通知机制》"><a href="#4-3-2《等待-通知机制》" class="headerlink" title="4.3.2《等待/通知机制》"></a>4.3.2《等待/通知机制》</h4><ul>
<li>一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），在功能层面上实现了解耦，体系结构上具备了良好的伸缩性</li>
<li>等待/通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</li>
<li>调用wait()、notify()以及notifyAll()时需要注意的细节，如下。<ul>
<li>使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</li>
<li>调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的等待队列。</li>
<li>notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为BLOCKED。</li>
<li>从wait()方法返回的前提是获得了调用对象的锁。</li>
</ul>
</li>
<li>等待/通知机制依托于同步机制，其目的就是确保等待线程从wait()方法返回时能够感知到通知线程对变量做出的修改。</li>
</ul>
<h4 id="4-3-3《等待-通知的经典范式》"><a href="#4-3-3《等待-通知的经典范式》" class="headerlink" title="4.3.3《等待/通知的经典范式》"></a>4.3.3《等待/通知的经典范式》</h4><ul>
<li>等待方遵循如下原则。<ul>
<li>获取对象的锁。</li>
<li>如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</li>
<li>条件满足则执行对应的逻辑。</li>
</ul>
</li>
<li>通知方遵循如下原则。<ul>
<li>获得对象的锁。</li>
<li>改变条件。</li>
<li>通知所有等待在对象上的线程。</li>
</ul>
</li>
</ul>
<h4 id="4-3-4《管道输入-输出流》"><a href="#4-3-4《管道输入-输出流》" class="headerlink" title="4.3.4《管道输入/输出流》"></a>4.3.4《管道输入/输出流》</h4><ul>
<li>管道输入/输出流和普通的文件输入/输出流或者网络输入/输出流不同之处在于，它主要用于线程之间的数据传输，而传输的媒介为内存。</li>
<li>管道输入/输出流主要包括了如下4种具体实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</li>
</ul>
<h4 id="4-3-5《Thread-join-的使用》"><a href="#4-3-5《Thread-join-的使用》" class="headerlink" title="4.3.5《Thread.join()的使用》"></a>4.3.5《Thread.join()的使用》</h4><ul>
<li>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。线程Thread除了提供join()方法之外，还提供了join(long millis)和join(long millis, int nanos)两个具备超时特性的方法。这两个超时方法表示，如果线程thread在给定的超时时间里没有终止，那么将会从该超时方法中返回。</li>
</ul>
<h4 id="4-3-6《ThreadLocal的使用》"><a href="#4-3-6《ThreadLocal的使用》" class="headerlink" title="4.3.6《ThreadLocal的使用》"></a>4.3.6《ThreadLocal的使用》</h4><ul>
<li>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个线程上的一个值。</li>
<li>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</li>
</ul>
<h3 id="4-4《线程应用实例》"><a href="#4-4《线程应用实例》" class="headerlink" title="4.4《线程应用实例》"></a>4.4《线程应用实例》</h3><h4 id="4-4-1《等待超时模式》"><a href="#4-4-1《等待超时模式》" class="headerlink" title="4.4.1《等待超时模式》"></a>4.4.1《等待超时模式》</h4><h4 id="4-4-2《一个简单的数据库连接池示例》"><a href="#4-4-2《一个简单的数据库连接池示例》" class="headerlink" title="4.4.2《一个简单的数据库连接池示例》"></a>4.4.2《一个简单的数据库连接池示例》</h4><h4 id="4-4-3《线程池技术及其示例》"><a href="#4-4-3《线程池技术及其示例》" class="headerlink" title="4.4.3《线程池技术及其示例》"></a>4.4.3《线程池技术及其示例》</h4><ul>
<li>线程池技术能够很好地解决这个问题，它预先创建了若干数量的线程，并且不能由用户直接对线程的创建进行控制，在这个前提下重复使用固定或较为固定数目的线程来完成任务的执行。这样做的好处是，一方面，消除了频繁创建和消亡线程的系统资源开销，另一方面，面对过量任务的提交能够平缓的劣化。</li>
</ul>
<h4 id="4-4-4《一个基于线程池技术的简单Web服务器》"><a href="#4-4-4《一个基于线程池技术的简单Web服务器》" class="headerlink" title="4.4.4《一个基于线程池技术的简单Web服务器》"></a>4.4.4《一个基于线程池技术的简单Web服务器》</h4><ul>
<li>线程池中线程数量并不是越多越好，具体的数量需要评估每个任务的处理时间，以及当前计算机的处理器能力和数量。使用的线程过少，无法发挥处理器的性能；使用的线程过多，将会增加系统的无故开销，起到相反的作用。</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="5-《Java中的锁》"><a href="#5-《Java中的锁》" class="headerlink" title="5.《Java中的锁》"></a>5.《Java中的锁》</h2><h3 id="5-1-《Lock接口》"><a href="#5-1-《Lock接口》" class="headerlink" title="5.1.《Lock接口》"></a>5.1.《Lock接口》</h3><ul>
<li>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。</li>
<li>Java SE 5之后，并发包中新增了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。</li>
<li>不要将获取锁的过程写在try块中，因为如果在获取锁（自定义锁的实现）时发生了异常，异常抛出的同时，也会导致锁无故释放。</li>
</ul>
<h3 id="5-2《队列同步器》"><a href="#5-2《队列同步器》" class="headerlink" title="5.2《队列同步器》"></a>5.2《队列同步器》</h3><ul>
<li>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。</li>
<li>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3个方法（getState()、setState(int newState)和compareAndSetState(int expect, int update)）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、ReentrantReadWriteLock和CountDownLatch等）。</li>
<li>锁是面向使用者的，它定义了使用者与锁交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。锁和同步器很好地隔离了使用者和实现者所需关注的领域。</li>
</ul>
<h4 id="5-2-1《队列同步器的接口与示例》"><a href="#5-2-1《队列同步器的接口与示例》" class="headerlink" title="5.2.1《队列同步器的接口与示例》"></a>5.2.1《队列同步器的接口与示例》</h4><ul>
<li>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些模板方法将会调用使用者重写的方法。</li>
</ul>
<h4 id="5-2-2《队列同步器的实现分析》"><a href="#5-2-2《队列同步器的实现分析》" class="headerlink" title="5.2.2《队列同步器的实现分析》"></a>5.2.2《队列同步器的实现分析》</h4><ul>
<li>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再次尝试获取同步状态。</li>
</ul>
<h3 id="5-3《重入锁》"><a href="#5-3《重入锁》" class="headerlink" title="5.3《重入锁》"></a>5.3《重入锁》</h3><ul>
<li>重入锁ReentrantLock，顾名思义，就是支持重进入的锁，它表示该锁能够支持一个线程对资源的重复加锁。除此之外，该锁的还支持获取锁时的公平和非公平性选择。</li>
<li>公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。</li>
<li>事实上，公平的锁机制往往没有非公平的效率高，但是，并不是任何场景都是以TPS作为唯一的指标，公平锁能够减少“饥饿”发生的概率，等待越久的请求越是能够得到优先满足。</li>
<li>公平性锁保证了锁的获取按照FIFO原则，而代价是进行大量的线程切换。非公平性锁虽然可能造成线程“饥饿”，但极少的线程切换，保证了其更大的吞吐量。</li>
</ul>
<h3 id="5-4《读写锁》"><a href="#5-4《读写锁》" class="headerlink" title="5.4《读写锁》"></a>5.4《读写锁》</h3><ul>
<li>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</li>
<li>只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。</li>
</ul>
<h4 id="5-4-1《读写锁的接口与示例》"><a href="#5-4-1《读写锁的接口与示例》" class="headerlink" title="5.4.1《读写锁的接口与示例》"></a>5.4.1《读写锁的接口与示例》</h4><ul>
<li>ReadWriteLock仅定义了获取读锁和写锁的两个方法，即readLock()方法和writeLock()方法，而其实现——ReentrantReadWriteLock，除了接口方法之外，还提供了一些便于外界监控其内部工作状态的方法。</li>
</ul>
<h4 id="5-4-2《读写锁的实现分析》"><a href="#5-4-2《读写锁的实现分析》" class="headerlink" title="5.4.2《读写锁的实现分析》"></a>5.4.2《读写锁的实现分析》</h4><ul>
<li>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。</li>
<li>读写锁要确保写锁的操作对读锁可见，如果允许读锁在已被获取的情况下对写锁的获取，那么正在运行的其他读线程就无法感知到当前写线程的操作。因此，只有等待其他读线程都释放了读锁，写锁才能被当前线程获取，而写锁一旦被获取，则其他读写线程的后续访问均被阻塞。</li>
<li>读锁是一个支持重进入的共享锁，它能够被多个线程同时获取，在没有其他写线程访问（或者写状态为0）时，读锁总会被成功地获取，而所做的也只是（线程安全的）增加读状态。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取，则进入等待状态。</li>
<li>读状态是所有线程获取读锁次数的总和，而每个线程各自获取读锁的次数只能选择保存在ThreadLocal中，由线程自身维护，这使获取读锁的实现变得复杂。</li>
<li>锁降级是指把持住（当前拥有的）写锁，再获取到读锁，随后释放（先前拥有的）写锁的过程。</li>
</ul>
<h3 id="5-5-《LockSupport工具》"><a href="#5-5-《LockSupport工具》" class="headerlink" title="5.5.《LockSupport工具》"></a>5.5.《LockSupport工具》</h3><h3 id="5-6-《Condition接口》"><a href="#5-6-《Condition接口》" class="headerlink" title="5.6.《Condition接口》"></a>5.6.《Condition接口》</h3><ul>
<li>任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式，但是这两者在使用方式以及功能特性上还是有差别的。</li>
</ul>
<h4 id="5-6-1《Condition接口与示例》"><a href="#5-6-1《Condition接口与示例》" class="headerlink" title="5.6.1《Condition接口与示例》"></a>5.6.1《Condition接口与示例》</h4><ul>
<li>Condition定义了等待/通知两种类型的方法，当前线程调用这些方法时，需要提前获取到Condition对象关联的锁。Condition对象是由Lock对象（调用Lock对象的newCondition()方法）创建出来的，换句话说，Condition是依赖Lock对象的。</li>
</ul>
<h4 id="5-6-2《Condition的实现分析》"><a href="#5-6-2《Condition的实现分析》" class="headerlink" title="5.6.2《Condition的实现分析》"></a>5.6.2《Condition的实现分析》</h4><ul>
<li>等待队列是一个FIFO的队列，在队列中的每个节点都包含了一个线程引用，该线程就是在Condition对象上等待的线程，如果一个线程调用了Condition.await()方法，那么该线程将会释放锁、构造成节点加入等待队列并进入等待状态。事实上，节点的定义复用了同步器中节点的定义，也就是说，同步队列和等待队列中节点类型都是同步器的静态内部类AbstractQueuedSynchronizer.Node。</li>
<li>调用Condition的await()方法（或者以await开头的方法），会使当前线程进入等待队列并释放锁，同时线程状态变为等待状态。当从await()方法返回时，当前线程一定获取了Condition相关联的锁。</li>
<li>如果从队列（同步队列和等待队列）的角度看await()方法，当调用await()方法时，相当于同步队列的首节点（获取了锁的节点）移动到Condition的等待队列中。</li>
<li>调用该方法的前置条件是当前线程必须获取了锁，可以看到signal()方法进行了isHeldExclusively()检查，也就是当前线程必须是获取了锁的线程。接着获取等待队列的首节点，将其移动到同步队列并使用LockSupport唤醒节点中的线程。</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="6-《Java并发容器和框架》"><a href="#6-《Java并发容器和框架》" class="headerlink" title="6.《Java并发容器和框架》"></a>6.《Java并发容器和框架》</h2><h3 id="6-1-《ConcurrentHashMap的实现原理与使用》"><a href="#6-1-《ConcurrentHashMap的实现原理与使用》" class="headerlink" title="6.1.《ConcurrentHashMap的实现原理与使用》"></a>6.1.《ConcurrentHashMap的实现原理与使用》</h3><h4 id="6-1-1-《为什么要使用ConcurrentHashMap》"><a href="#6-1-1-《为什么要使用ConcurrentHashMap》" class="headerlink" title="6.1.1.《为什么要使用ConcurrentHashMap》"></a>6.1.1.《为什么要使用ConcurrentHashMap》</h4><ul>
<li>在多线程环境下，使用HashMap进行put操作会引起死循环，导致CPU利用率接近100%，所以在并发情况下不能使用HashMap。</li>
<li>HashMap在并发执行put操作时会引起死循环，是因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点永远不为空，就会产生死循环获取Entry。</li>
<li>HashTable容器使用synchronized来保证线程安全，但在线程竞争激烈的情况下HashTable的效率非常低下。因为当一个线程访问HashTable的同步方法，其他线程也访问HashTable的同步方法时，会进入阻塞或轮询状态。如线程1使用put进行元素添加，线程2不但不能使用put方法添加元素，也不能使用get方法来获取元素，所以竞争越激烈效率越低。</li>
<li>ConcurrentHashMap所使用的锁分段技术。首先将数据分成一段一段地存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
</ul>
<h4 id="6-1-2-《ConcurrentHashMap的结构》"><a href="#6-1-2-《ConcurrentHashMap的结构》" class="headerlink" title="6.1.2.《ConcurrentHashMap的结构》"></a>6.1.2.《ConcurrentHashMap的结构》</h4><ul>
<li>ConcurrentHashMap是由Segment数组结构和HashEntry数组结构组成。Segment是一种可重入锁（ReentrantLock），在ConcurrentHashMap里扮演锁的角色；HashEntry则用于存储键值对数据。一个ConcurrentHashMap里包含一个Segment数组。Segment的结构和HashMap类似，是一种数组和链表结构。一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。</li>
<li>ConcurrentHashMap初始化方法是通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMask和每个segment里的HashEntry数组来实现的。</li>
<li>concurrencyLevel的最大值是65535，这意味着segments数组的长度最大为65536，对应的二进制是16位。</li>
</ul>
<h4 id="6-1-3-《ConcurrentHashMap的操作》"><a href="#6-1-3-《ConcurrentHashMap的操作》" class="headerlink" title="6.1.3.《ConcurrentHashMap的操作》"></a>6.1.3.《ConcurrentHashMap的操作》</h4><ul>
<li>get操作的高效之处在于整个get过程不需要加锁，除非读到的值是空才会加锁重读。</li>
<li>在扩容的时候，首先会创建一个容量是原来容量两倍的数组，然后将原数组里的元素进行再散列后插入到新的数组里。为了高效，ConcurrentHashMap不会对整个容器进行扩容，而只对某个segment进行扩容。<h3 id="6-2-《ConcurrentLinkedQueue》"><a href="#6-2-《ConcurrentLinkedQueue》" class="headerlink" title="6.2.《ConcurrentLinkedQueue》"></a>6.2.《ConcurrentLinkedQueue》</h3><h4 id="6-2-1-《ConcurrentLinkedQueue的结构》"><a href="#6-2-1-《ConcurrentLinkedQueue的结构》" class="headerlink" title="6.2.1.《ConcurrentLinkedQueue的结构》"></a>6.2.1.《ConcurrentLinkedQueue的结构》</h4><h4 id="6-2-2-《入队列》"><a href="#6-2-2-《入队列》" class="headerlink" title="6.2.2.《入队列》"></a>6.2.2.《入队列》</h4><h4 id="6-2-3-《出队列》"><a href="#6-2-3-《出队列》" class="headerlink" title="6.2.3.《出队列》"></a>6.2.3.《出队列》</h4><h3 id="6-3-《Java中的阻塞队列》"><a href="#6-3-《Java中的阻塞队列》" class="headerlink" title="6.3.《Java中的阻塞队列》"></a>6.3.《Java中的阻塞队列》</h3><h4 id="6-3-1-《什么是阻塞队列》"><a href="#6-3-1-《什么是阻塞队列》" class="headerlink" title="6.3.1.《什么是阻塞队列》"></a>6.3.1.《什么是阻塞队列》</h4></li>
<li>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法。<ul>
<li>支持阻塞的插入方法：意思是当队列满时，队列会阻塞插入元素的线程，直到队列不满。</li>
<li>支持阻塞的移除方法：意思是在队列为空时，获取元素的线程会等待队列变为非空。</li>
</ul>
</li>
</ul>
<h4 id="6-3-2-《Java里的阻塞队列》"><a href="#6-3-2-《Java里的阻塞队列》" class="headerlink" title="6.3.2.《Java里的阻塞队列》"></a>6.3.2.《Java里的阻塞队列》</h4><ul>
<li>JDK 7提供了7个阻塞队列，如下。<ul>
<li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列。</li>
<li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列。</li>
<li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li>
<li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。</li>
<li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li>
<li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li>
</ul>
</li>
</ul>
<h4 id="6-3-3-《阻塞队列的实现原理》"><a href="#6-3-3-《阻塞队列的实现原理》" class="headerlink" title="6.3.3.《阻塞队列的实现原理》"></a>6.3.3.《阻塞队列的实现原理》</h4><h3 id="6-4-《Fork-Join框架》"><a href="#6-4-《Fork-Join框架》" class="headerlink" title="6.4.《Fork/Join框架》"></a>6.4.《Fork/Join框架》</h3><h4 id="6-4-1《什么是Fork-Join框架》"><a href="#6-4-1《什么是Fork-Join框架》" class="headerlink" title="6.4.1《什么是Fork/Join框架》"></a>6.4.1《什么是Fork/Join框架》</h4><ul>
<li>Fork/Join框架是Java 7提供的一个用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</li>
</ul>
<h4 id="6-4-2-《工作窃取算法》"><a href="#6-4-2-《工作窃取算法》" class="headerlink" title="6.4.2.《工作窃取算法》"></a>6.4.2.《工作窃取算法》</h4><ul>
<li>工作窃取（work-stealing）算法是指某个线程从其他队列里窃取任务来执行。</li>
<li>工作窃取算法的优点：充分利用线程进行并行计算，减少了线程间的竞争。</li>
<li>工作窃取算法的缺点：在某些情况下还是存在竞争，比如双端队列里只有一个任务时。并且该算法会消耗了更多的系统资源，比如创建多个线程和多个双端队列。</li>
</ul>
<h4 id="6-4-3-《Fork-Join框架的设计》"><a href="#6-4-3-《Fork-Join框架的设计》" class="headerlink" title="6.4.3.《Fork/Join框架的设计》"></a>6.4.3.《Fork/Join框架的设计》</h4><h4 id="6-4-4-《使用Fork-Join框架》"><a href="#6-4-4-《使用Fork-Join框架》" class="headerlink" title="6.4.4.《使用Fork/Join框架》"></a>6.4.4.《使用Fork/Join框架》</h4><h4 id="6-4-5-《Fork-Join框架的异常处理》"><a href="#6-4-5-《Fork-Join框架的异常处理》" class="headerlink" title="6.4.5.《Fork/Join框架的异常处理》"></a>6.4.5.《Fork/Join框架的异常处理》</h4><ul>
<li>ForkJoinTask在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常。</li>
<li>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</li>
</ul>
<h4 id="6-4-6-《Fork-Join框架的实现原理》"><a href="#6-4-6-《Fork-Join框架的实现原理》" class="headerlink" title="6.4.6.《Fork/Join框架的实现原理》"></a>6.4.6.《Fork/Join框架的实现原理》</h4><p><br /><br /><br /></p>
<h2 id="7-《Java中的13个原子操作类》"><a href="#7-《Java中的13个原子操作类》" class="headerlink" title="7.《Java中的13个原子操作类》"></a>7.《Java中的13个原子操作类》</h2><ul>
<li>Atomic包里一共提供了13个类，属于4种类型的原子更新方式，分别是原子更新基本类型、原子更新数组、原子更新引用和原子更新属性（字段）。Atomic包里的类基本都是使用Unsafe实现的包装类。</li>
</ul>
<h3 id="7-1-《原子更新基本类型类》"><a href="#7-1-《原子更新基本类型类》" class="headerlink" title="7.1.《原子更新基本类型类》"></a>7.1.《原子更新基本类型类》</h3><h3 id="7-2-《原子更新数组》"><a href="#7-2-《原子更新数组》" class="headerlink" title="7.2.《原子更新数组》"></a>7.2.《原子更新数组》</h3><h3 id="7-3-《原子更新引用类型》"><a href="#7-3-《原子更新引用类型》" class="headerlink" title="7.3.《原子更新引用类型》"></a>7.3.《原子更新引用类型》</h3><h3 id="7-4-《原子更新字段类》"><a href="#7-4-《原子更新字段类》" class="headerlink" title="7.4.《原子更新字段类》"></a>7.4.《原子更新字段类》</h3><p><br /><br /><br /></p>
<h2 id="8-《Java中的并发工具类》"><a href="#8-《Java中的并发工具类》" class="headerlink" title="8.《Java中的并发工具类》"></a>8.《Java中的并发工具类》</h2><ul>
<li>CountDownLatch、CyclicBarrier和Semaphore工具类提供了一种并发流程控制的手段，Exchanger工具类则提供了在线程间交换数据的一种手段。<h3 id="8-1-《等待多线程完成的CountDownLatch》"><a href="#8-1-《等待多线程完成的CountDownLatch》" class="headerlink" title="8.1.《等待多线程完成的CountDownLatch》"></a>8.1.《等待多线程完成的CountDownLatch》</h3><h3 id="8-2-《同步屏障CyclicBarrier》"><a href="#8-2-《同步屏障CyclicBarrier》" class="headerlink" title="8.2.《同步屏障CyclicBarrier》"></a>8.2.《同步屏障CyclicBarrier》</h3></li>
<li>它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</li>
</ul>
<h4 id="8-2-1-《CyclicBarrier简介》"><a href="#8-2-1-《CyclicBarrier简介》" class="headerlink" title="8.2.1.《CyclicBarrier简介》"></a>8.2.1.《CyclicBarrier简介》</h4><ul>
<li>CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
<h4 id="8-2-2-《CyclicBarrier的应用场景》"><a href="#8-2-2-《CyclicBarrier的应用场景》" class="headerlink" title="8.2.2.《CyclicBarrier的应用场景》"></a>8.2.2.《CyclicBarrier的应用场景》</h4><h4 id="8-2-3-《CyclicBarrier和CountDownLatch的区别》"><a href="#8-2-3-《CyclicBarrier和CountDownLatch的区别》" class="headerlink" title="8.2.3.《CyclicBarrier和CountDownLatch的区别》"></a>8.2.3.《CyclicBarrier和CountDownLatch的区别》</h4><ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。所以CyclicBarrier能处理更为复杂的业务场景。例如，如果计算发生错误，可以重置计数器，并让线程重新执行一次。<h3 id="8-3-《控制并发线程数的Semaphore》"><a href="#8-3-《控制并发线程数的Semaphore》" class="headerlink" title="8.3.《控制并发线程数的Semaphore》"></a>8.3.《控制并发线程数的Semaphore》</h3></li>
<li>Semaphore（信号量）是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源。<h3 id="8-4-《线程间交换数据的Exchanger》"><a href="#8-4-《线程间交换数据的Exchanger》" class="headerlink" title="8.4.《线程间交换数据的Exchanger》"></a>8.4.《线程间交换数据的Exchanger》</h3></li>
<li>Exchanger（交换者）是一个用于线程间协作的工具类。Exchanger用于进行线程间的数据交换。它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange方法交换数据，如果第一个线程先执行exchange()方法，它会一直等待第二个线程也执行exchange方法，当两个线程都到达同步点时，这两个线程就可以交换数据，将本线程生产出来的数据传递给对方。</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="9-《Java中的线程池》"><a href="#9-《Java中的线程池》" class="headerlink" title="9.《Java中的线程池》"></a>9.《Java中的线程池》</h2><ul>
<li>第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li>
<li>第三：提高线程的可管理性。线程是稀缺资源，如果无限制地创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一分配、调优和监控。但是，要做到合理利用线程池，必须对其实现原理了如指掌。<h3 id="9-1《线程池的实现原理》"><a href="#9-1《线程池的实现原理》" class="headerlink" title="9.1《线程池的实现原理》"></a>9.1《线程池的实现原理》</h3></li>
<li>线程池的处理流程如下。<ul>
<li>线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</li>
<li>线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这个工作队列里。如果工作队列满了，则进入下个流程。</li>
<li>线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程来执行任务。如果已经满了，则交给饱和策略来处理这个任务。<h3 id="9-2-《线程池的使用》"><a href="#9-2-《线程池的使用》" class="headerlink" title="9.2.《线程池的使用》"></a>9.2.《线程池的使用》</h3><h4 id="9-2-1-《线程池的创建》"><a href="#9-2-1-《线程池的创建》" class="headerlink" title="9.2.1.《线程池的创建》"></a>9.2.1.《线程池的创建》</h4></li>
</ul>
</li>
<li>线程池时需要输入几个参数，如下：<ul>
<li>corePoolSize（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，线程池会提前创建并启动所有基本线程。</li>
<li>runnableTaskQueue（任务队列）：用于保存等待执行的任务的阻塞队列。可以选择以下几个阻塞队列。<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li>maximumPoolSize（线程池最大数量）：线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如果使用了无界的任务队列这个参数就没什么效果。</li>
<li>ThreadFactory：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线程设置有意义的名字，代码如下。</li>
<li>RejectedExecutionHandler（饱和策略）：当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法处理新任务时抛出异常。<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
<li>keepAliveTime（线程活动保持时间）：线程池的工作线程空闲后，保持存活的时间。所以，如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</li>
<li>TimeUnit（线程活动保持时间的单位）：可选的单位有天（DAYS）、小时（HOURS）、分钟（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="9-2-2-《向线程池提交任务》"><a href="#9-2-2-《向线程池提交任务》" class="headerlink" title="9.2.2.《向线程池提交任务》"></a>9.2.2.《向线程池提交任务》</h4><ul>
<li>可以使用两个方法向线程池提交任务，分别为execute()和submit()方法。</li>
<li>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。</li>
<li>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</li>
</ul>
<h4 id="9-2-3-《关闭线程池》"><a href="#9-2-3-《关闭线程池》" class="headerlink" title="9.2.3.《关闭线程池》"></a>9.2.3.《关闭线程池》</h4><ul>
<li>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。它们的原理是遍历线程池中的工作线程，然后逐个调用线程的interrupt方法来中断线程，所以无法响应中断的任务可能永远无法终止。</li>
<li>但是它们存在一定的区别，shutdownNow首先将线程池的状态设置成STOP，然后尝试停止所有的正在执行或暂停任务的线程，并返回等待执行任务的列表，而shutdown只是将线程池的状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程。</li>
<li>只要调用了这两个关闭方法中的任意一个，isShutdown方法就会返回true。当所有的任务都已关闭后，才表示线程池关闭成功，这时调用isTerminaed方法会返回true。至于应该调用哪一种方法来关闭线程池，应该由提交到线程池的任务特性决定，通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法。</li>
</ul>
<h4 id="9-2-4-《合理地配置线程池》"><a href="#9-2-4-《合理地配置线程池》" class="headerlink" title="9.2.4.《合理地配置线程池》"></a>9.2.4.《合理地配置线程池》</h4><ul>
<li>如果一直有优先级高的任务提交到队列里，那么优先级低的任务可能永远不能执行。</li>
<li>执行时间不同的任务可以交给不同规模的线程池来处理，或者可以使用优先级队列，让执行时间短的任务先执行。</li>
<li>依赖数据库连接池的任务，因为线程提交SQL后需要等待数据库返回结果，等待的时间越长，则CPU空闲时间就越长，那么线程数应该设置得越大，这样才能更好地利用CPU。</li>
</ul>
<h4 id="9-2-5-《线程池的监控》"><a href="#9-2-5-《线程池的监控》" class="headerlink" title="9.2.5.《线程池的监控》"></a>9.2.5.《线程池的监控》</h4><ul>
<li>监控线程池的时候可以使用以下属性：<ul>
<li>taskCount：线程池需要执行的任务数量。</li>
<li>completedTaskCount：线程池在运行过程中已完成的任务数量，小于或等于taskCount。</li>
<li>largestPoolSize：线程池里曾经创建过的最大线程数量。通过这个数据可以知道线程池是否曾经满过。如该数值等于线程池的最大大小，则表示线程池曾经满过。</li>
<li>getPoolSize：线程池的线程数量。如果线程池不销毁的话，线程池里的线程不会自动销毁，所以这个大小只增不减。</li>
<li>getActiveCount：获取活动的线程数。</li>
</ul>
</li>
</ul>
<p><br /><br /><br /></p>
<h2 id="10-《Executor框架》"><a href="#10-《Executor框架》" class="headerlink" title="10.《Executor框架》"></a>10.《Executor框架》</h2><ul>
<li>在Java中，使用线程来异步执行任务。Java线程的创建与销毁需要一定的开销，如果我们为每一个任务创建一个新线程来执行，这些线程的创建与销毁将消耗大量的计算资源。同时，为每一个任务创建一个新线程来执行，这种策略可能会使处于高负荷状态的应用最终崩溃。</li>
<li>Java的线程既是工作单元，也是执行机制。从JDK 5开始，把工作单元与执行机制分离开来。工作单元包括Runnable和Callable，而执行机制由Executor框架提供。</li>
</ul>
<h3 id="10-1-《Executor框架简介》"><a href="#10-1-《Executor框架简介》" class="headerlink" title="10.1.《Executor框架简介》"></a>10.1.《Executor框架简介》</h3><h4 id="10-1-1-《Executor框架的两级调度模型》"><a href="#10-1-1-《Executor框架的两级调度模型》" class="headerlink" title="10.1.1.《Executor框架的两级调度模型》"></a>10.1.1.《Executor框架的两级调度模型》</h4><ul>
<li>在HotSpot VM的线程模型中，Java线程（java.lang.Thread）被一对一映射为本地操作系统线程。Java线程启动时会创建一个本地操作系统线程；当该Java线程终止时，这个操作系统线程也会被回收。操作系统会调度所有线程并将它们分配给可用的CPU。</li>
<li>在上层，Java多线程程序通常把应用分解为若干个任务，然后使用用户级的调度器（Executor框架）将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件处理器上。</li>
</ul>
<h4 id="10-1-2-《Executor框架的结构与成员》"><a href="#10-1-2-《Executor框架的结构与成员》" class="headerlink" title="10.1.2.《Executor框架的结构与成员》"></a>10.1.2.《Executor框架的结构与成员》</h4><ul>
<li>Executor框架主要由3大部分组成如下：<ul>
<li>任务。包括被执行任务需要实现的接口：Runnable接口或Callable接口。</li>
<li>任务的执行。包括任务执行机制的核心接口Executor，以及继承自Executor的ExecutorService接口。Executor框架有两个关键类实现了ExecutorService接口（ThreadPoolExecutor和ScheduledThreadPoolExecutor）。</li>
<li>异步计算的结果。包括接口Future和实现Future接口的FutureTask类。</li>
</ul>
</li>
</ul>
<h3 id="10-2-《ThreadPoolExecutor详解》"><a href="#10-2-《ThreadPoolExecutor详解》" class="headerlink" title="10.2.《ThreadPoolExecutor详解》"></a>10.2.《ThreadPoolExecutor详解》</h3><ul>
<li>Executor框架最核心的类是ThreadPoolExecutor，它是线程池的实现类，主要由下列4个组件构成：<ul>
<li>corePool：核心线程池的大小。</li>
<li>maximumPool：最大线程池的大小。</li>
<li>BlockingQueue：用来暂时保存任务的工作队列。</li>
<li>RejectedExecutionHandler：当ThreadPoolExecutor已经关闭或ThreadPoolExecutor已经饱和时（达到了最大线程池大小且工作队列已满），execute()方法将要调用的Handler。</li>
</ul>
</li>
<li>通过Executor框架的工具类Executors，可以创建3种类型的ThreadPoolExecutor。<ul>
<li>FixedThreadPool。</li>
<li>SingleThreadExecutor。</li>
<li>CachedThreadPool。</li>
</ul>
</li>
</ul>
<h4 id="10-2-1-《FixedThreadPool详解》"><a href="#10-2-1-《FixedThreadPool详解》" class="headerlink" title="10.2.1.《FixedThreadPool详解》"></a>10.2.1.《FixedThreadPool详解》</h4><ul>
<li>FixedThreadPool被称为可重用固定线程数的线程池。</li>
<li>当线程池中的线程数大于corePoolSize时，keepAliveTime为多余的空闲线程等待新任务的最长时间，超过这个时间后多余的线程将被终止。这里把keepAliveTime设置为0L，意味着多余的空闲线程会被立即终止。</li>
<li>如果当前运行的线程数少于corePoolSize，则创建新线程来执行任务。</li>
<li>在线程池完成预热之后（当前运行的线程数等于corePoolSize），将任务加入LinkedBlockingQueue。</li>
<li>线程执行完1中的任务后，会在循环中反复从LinkedBlockingQueue获取任务来执行。</li>
<li>FixedThreadPool使用无界队列LinkedBlockingQueue作为线程池的工作队列（队列的容量为Integer.MAX_VALUE）。使用无界队列作为工作队列会对线程池带来如下影响：<ul>
<li>当线程池中的线程数达到corePoolSize后，新任务将在无界队列中等待，因此线程池中的线程数不会超过corePoolSize。</li>
<li>由于1，使用无界队列时maximumPoolSize将是一个无效参数。</li>
<li>由于1和2，使用无界队列时keepAliveTime将是一个无效参数。</li>
<li>由于使用无界队列，运行中的FixedThreadPool（未执行方法shutdown()或shutdownNow()）不会拒绝任务（不会调用RejectedExecutionHandler.rejectedExecution方法）。</li>
</ul>
</li>
</ul>
<h4 id="10-2-2-《SingleThreadExecutor详解》"><a href="#10-2-2-《SingleThreadExecutor详解》" class="headerlink" title="10.2.2.《SingleThreadExecutor详解》"></a>10.2.2.《SingleThreadExecutor详解》</h4><ul>
<li>SingleThreadExecutor是使用单个worker线程的Executor。</li>
</ul>
<h4 id="10-2-3-《CachedThreadPool详解》"><a href="#10-2-3-《CachedThreadPool详解》" class="headerlink" title="10.2.3.《CachedThreadPool详解》"></a>10.2.3.《CachedThreadPool详解》</h4><ul>
<li>CachedThreadPool是一个会根据需要创建新线程的线程池。</li>
<li>CachedThreadPool的corePoolSize被设置为0，即corePool为空；maximumPoolSize被设置为Integer.MAX_VALUE，即maximumPool是无界的。这里把keepAliveTime设置为60L，意味着CachedThreadPool中的空闲线程等待新任务的最长时间为60秒，空闲线程超过60秒后将会被终止。</li>
<li>FixedThreadPool和SingleThreadExecutor使用无界队列LinkedBlockingQueue作为线程池的工作队列。CachedThreadPool使用没有容量的SynchronousQueue作为线程池的工作队列，但CachedThreadPool的maximumPool是无界的。这意味着，如果主线程提交任务的速度高于maximumPool中线程处理任务的速度时，CachedThreadPool会不断创建新线程。极端情况下，CachedThreadPool会因为创建过多线程而耗尽CPU和内存资源。</li>
</ul>
<h4 id="10-2-4-《ScheduledThreadPoolExecutor详解》"><a href="#10-2-4-《ScheduledThreadPoolExecutor详解》" class="headerlink" title="10.2.4.《ScheduledThreadPoolExecutor详解》"></a>10.2.4.《ScheduledThreadPoolExecutor详解》</h4><ul>
<li>ScheduledThreadPoolExecutor继承自ThreadPoolExecutor。它主要用来在给定的延迟之后运行任务，或者定期执行任务。ScheduledThreadPoolExecutor的功能与Timer类似，但ScheduledThreadPoolExecutor功能更强大、更灵活。Timer对应的是单个后台线程，而ScheduledThreadPoolExecutor可以在构造函数中指定多个对应的后台线程数。</li>
<li>DelayQueue是一个无界队列，所以ThreadPoolExecutor的maximumPoolSize在Scheduled-ThreadPoolExecutor中没有什么意义（设置maximumPoolSize的大小没有什么效果）。</li>
<li>当调用ScheduledThreadPoolExecutor的scheduleAtFixedRate()方法或者scheduleWith-FixedDelay()方法时，会向ScheduledThreadPoolExecutor的DelayQueue添加一个实现了RunnableScheduledFutur接口的ScheduledFutureTask。</li>
<li>线程池中的线程从DelayQueue中获取ScheduledFutureTask，然后执行任务。</li>
<li>DelayQueue封装了一个PriorityQueue，这个PriorityQueue会对队列中的Scheduled-FutureTask进行排序。排序时，time小的排在前面（时间早的任务将被先执行）。如果两个ScheduledFutureTask的time相同，就比较sequenceNumber，sequenceNumber小的排在前面（也就是说，如果两个任务的执行时间相同，那么先提交的任务将被先执行）。</li>
</ul>
<h3 id="10-3-《FutureTask详解》"><a href="#10-3-《FutureTask详解》" class="headerlink" title="10.3.《FutureTask详解》"></a>10.3.《FutureTask详解》</h3><ul>
<li>FutureTask除了实现Future接口外，还实现了Runnable接口。因此，FutureTask可以交给Executor执行，也可以由调用线程直接执行（FutureTask.run()）。</li>
<li>AQS是一个同步框架，它提供通用机制来原子性管理同步状态、阻塞和唤醒线程，以及维护被阻塞线程的队列。</li>
<li>每一个基于AQS实现的同步器都会包含两种类型的操作，如下：<ul>
<li>至少一个acquire操作。这个操作阻塞调用线程，除非/直到AQS的状态允许这个线程继续执行。FutureTask的acquire操作为get()/get（long timeout，TimeUnit unit）方法调用。</li>
<li>至少一个release操作。这个操作改变AQS的状态，改变后的状态可允许一个或多个阻塞线程被解除阻塞。FutureTask的release操作包括run()方法和cancel（…）方法。</li>
</ul>
</li>
</ul>
<h2 id="11-《Java并发编程实践》"><a href="#11-《Java并发编程实践》" class="headerlink" title="11.《Java并发编程实践》"></a>11.《Java并发编程实践》</h2><h3 id="11-1-《生产者和消费者模式》"><a href="#11-1-《生产者和消费者模式》" class="headerlink" title="11.1.《生产者和消费者模式》"></a>11.1.《生产者和消费者模式》</h3><ul>
<li>生产者和消费者模式是通过一个容器来解决生产者和消费者的强耦合问题。生产者和消费者彼此之间不直接通信，而是通过阻塞队列来进行通信，所以生产者生产完数据之后不用等待消费者处理，直接扔给阻塞队列，消费者不找生产者要数据，而是直接从阻塞队列里取，阻塞队列就相当于一个缓冲区，平衡了生产者和消费者的处理能力。<h3 id="11-2-《线上问题定位》"><a href="#11-2-《线上问题定位》" class="headerlink" title="11.2.《线上问题定位》"></a>11.2.《线上问题定位》</h3><h3 id="11-3-《性能测试》"><a href="#11-3-《性能测试》" class="headerlink" title="11.3.《性能测试》"></a>11.3.《性能测试》</h3></li>
<li>查询端口链接数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 服务链接数</span><br><span class="line">netstat -nat |grep 8080 -c</span><br><span class="line"># 数据库链接数</span><br><span class="line">netstat -nat |grep 3306 -c</span><br></pre></td></tr></table></figure></li>
<li>查询服务的线程数是<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -eLF |grep java -c</span><br></pre></td></tr></table></figure></li>
<li>其他linux命令<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查看系统cpu信息</span><br><span class="line">cat &#x2F;proc&#x2F;cpuinfo</span><br><span class="line"></span><br><span class="line"># 查询系统平均负载</span><br><span class="line">cat &#x2F;proc&#x2F;loadavg</span><br><span class="line"></span><br><span class="line"># 查看系统内存情况</span><br><span class="line">cat &#x2F;proc&#x2F;meminfo</span><br><span class="line"></span><br><span class="line"># 查看系统cpu利用率</span><br><span class="line">cat &#x2F;proc&#x2F;stat</span><br><span class="line"></span><br><span class="line"># 查看网络流量</span><br><span class="line">cat &#x2F;proc&#x2F;net&#x2F;dev</span><br></pre></td></tr></table></figure>

</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%98%85%E8%AF%BB/" rel="tag"># 阅读</a>
              <a href="/tags/%E6%8A%80%E6%9C%AF/" rel="tag"># 技术</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/13/%E9%98%85%E8%AF%BB%E7%AF%87/%E5%B7%B2%E8%AF%BB/%E3%80%8A%E6%96%87%E5%8D%9A%E5%A3%AB%E3%80%8B_%E8%80%81%E8%88%8D/" rel="prev" title="《文博士》_老舍">
      <i class="fa fa-chevron-left"></i> 《文博士》_老舍
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/04/14/%E6%8A%80%E8%83%BD%E7%AF%87/%E8%BD%AF%E8%80%83/%E3%80%8A%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%B8%88%E6%95%99%E7%A8%8B%E3%80%8B/" rel="next" title="《软件设计教程》">
      《软件设计教程》 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%91%98%E5%BD%95"><span class="nav-number">1.</span> <span class="nav-text">摘录</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%8C%91%E6%88%98%E3%80%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.《并发编程的挑战》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1%E3%80%8A%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E3%80%8B"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1《上下文切换》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2%E3%80%8A%E6%AD%BB%E9%94%81%E3%80%8B"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.2《死锁》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3%E3%80%8A%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6%E7%9A%84%E6%8C%91%E6%88%98%E3%80%8B"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.3《资源限制的挑战》</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-%E3%80%8AJava%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B"><span class="nav-number">1.2.</span> <span class="nav-text">2.《Java并发机制的底层实现原理》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E3%80%8Avolatile%E7%9A%84%E5%BA%94%E7%94%A8%E3%80%8B"><span class="nav-number">1.2.1.</span> <span class="nav-text">2.1《volatile的应用》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E3%80%8Asynchronized%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E3%80%8B"><span class="nav-number">1.2.2.</span> <span class="nav-text">2.2《synchronized的实现原理与应用》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1%E3%80%8AJava%E5%AF%B9%E8%B1%A1%E5%A4%B4%E3%80%8B"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">2.2.1《Java对象头》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-2%E3%80%8A%E9%94%81%E7%9A%84%E5%8D%87%E7%BA%A7%E4%B8%8E%E5%AF%B9%E6%AF%94%E3%80%8B"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">2.2.2《锁的升级与对比》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3%E3%80%8A%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B"><span class="nav-number">1.2.3.</span> <span class="nav-text">2.3《原子操作的实现原理》</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E3%80%8AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%8B"><span class="nav-number">1.3.</span> <span class="nav-text">3.《Java内存模型》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1%E3%80%8Ajava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%9F%BA%E7%A1%80%E3%80%8B"><span class="nav-number">1.3.1.</span> <span class="nav-text">3.1《java内存模型的基础》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%85%B3%E9%94%AE%E9%97%AE%E9%A2%98%E3%80%8B"><span class="nav-number">1.3.1.1.</span> <span class="nav-text">3.1.1《并发编程模型的两个关键问题》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2%E3%80%8AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E6%8A%BD%E8%B1%A1%E7%BB%93%E6%9E%84%E3%80%8B"><span class="nav-number">1.3.1.2.</span> <span class="nav-text">3.1.2《Java内存模型的抽象结构》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3%E3%80%8A%E4%BB%8E%E6%BA%90%E4%BB%A3%E7%A0%81%E5%88%B0%E6%8C%87%E4%BB%A4%E5%BA%8F%E5%88%97%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E3%80%8B"><span class="nav-number">1.3.1.3.</span> <span class="nav-text">3.1.3《从源代码到指令序列的重排序》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4%E3%80%8A%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E7%9A%84%E5%88%86%E7%B1%BB%E3%80%8B"><span class="nav-number">1.3.1.4.</span> <span class="nav-text">3.1.4《并发编程模型的分类》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-5%E3%80%8Ahappens-before%E7%AE%80%E4%BB%8B%E3%80%8B"><span class="nav-number">1.3.1.5.</span> <span class="nav-text">3.1.5《happens-before简介》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2%E3%80%8A%E9%87%8D%E6%8E%92%E5%BA%8F%E3%80%8B"><span class="nav-number">1.3.2.</span> <span class="nav-text">3.2《重排序》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1%E3%80%8A%E6%95%B0%E6%8D%AE%E4%BE%9D%E8%B5%96%E6%80%A7%E3%80%8B"><span class="nav-number">1.3.2.1.</span> <span class="nav-text">3.2.1《数据依赖性》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2%E3%80%8Aas-if-serial%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.2.2.</span> <span class="nav-text">3.2.2《as-if-serial语义》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3%E3%80%8A%E7%A8%8B%E5%BA%8F%E9%A1%BA%E5%BA%8F%E8%A7%84%E5%88%99%E3%80%8B"><span class="nav-number">1.3.2.3.</span> <span class="nav-text">3.2.3《程序顺序规则》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4%E3%80%8A%E9%87%8D%E6%8E%92%E5%BA%8F%E5%AF%B9%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%BD%B1%E5%93%8D%E3%80%8B"><span class="nav-number">1.3.2.4.</span> <span class="nav-text">3.2.4《重排序对多线程的影响》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3%E3%80%8A%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%8B"><span class="nav-number">1.3.3.</span> <span class="nav-text">3.3《顺序一致性》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1%E3%80%8A%E6%95%B0%E6%8D%AE%E7%AB%9E%E4%BA%89%E4%B8%8E%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%8B"><span class="nav-number">1.3.3.1.</span> <span class="nav-text">3.3.1《数据竞争与顺序一致性》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2%E3%80%8A%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%8B"><span class="nav-number">1.3.3.2.</span> <span class="nav-text">3.3.2《顺序一致性内存模型》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3%E3%80%8A%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%A1%BA%E5%BA%8F%E4%B8%80%E8%87%B4%E6%80%A7%E6%95%88%E6%9E%9C%E3%80%8B"><span class="nav-number">1.3.3.3.</span> <span class="nav-text">3.3.3《同步程序的顺序一致性效果》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4%E3%80%8A%E6%9C%AA%E5%90%8C%E6%AD%A5%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%89%A7%E8%A1%8C%E7%89%B9%E6%80%A7%E3%80%8B"><span class="nav-number">1.3.3.4.</span> <span class="nav-text">3.3.4《未同步程序的执行特性》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4%E3%80%8Avolatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.4.</span> <span class="nav-text">3.4《volatile的内存语义》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1%E3%80%8Avolatile%E7%9A%84%E7%89%B9%E6%80%A7%E3%80%8B"><span class="nav-number">1.3.4.1.</span> <span class="nav-text">3.4.1《volatile的特性》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2%E3%80%8Avolatile%E5%86%99-%E8%AF%BB%E5%BB%BA%E7%AB%8B%E7%9A%84happens-before%E5%85%B3%E7%B3%BB%E3%80%8B"><span class="nav-number">1.3.4.2.</span> <span class="nav-text">3.4.2《volatile写-读建立的happens-before关系》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3%E3%80%8Avolatile%E5%86%99-%E8%AF%BB%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.4.3.</span> <span class="nav-text">3.4.3《volatile写-读的内存语义》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-4%E3%80%8Avolatile%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%8B"><span class="nav-number">1.3.4.4.</span> <span class="nav-text">3.4.4《volatile内存语义的实现》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-5%E3%80%8AJSR-133%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%A2%9E%E5%BC%BAvolatile%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.4.5.</span> <span class="nav-text">3.4.5《JSR-133为什么要增强volatile的内存语义》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5%E3%80%8A%E9%94%81%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.5.</span> <span class="nav-text">3.5《锁的内存语义》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-1%E3%80%8A%E9%94%81%E7%9A%84%E9%87%8A%E6%94%BE%E5%92%8C%E8%8E%B7%E5%8F%96%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.5.1.</span> <span class="nav-text">3.5.1《锁的释放和获取的内存语义》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-2%E3%80%8A%E9%94%81%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%8B"><span class="nav-number">1.3.5.2.</span> <span class="nav-text">3.5.2《锁内存语义的实现》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-3%E3%80%8Aconcurrent%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%8B"><span class="nav-number">1.3.5.3.</span> <span class="nav-text">3.5.3《concurrent包的实现》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6%E3%80%8Afinal%E5%9F%9F%E7%9A%84%E5%86%85%E5%AD%98%E8%AF%AD%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.6.</span> <span class="nav-text">3.6《final域的内存语义》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-1%E3%80%8Afinal%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E3%80%8B"><span class="nav-number">1.3.6.1.</span> <span class="nav-text">3.6.1《final域的重排序规则》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-2%E3%80%8A%E5%86%99final%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E3%80%8B"><span class="nav-number">1.3.6.2.</span> <span class="nav-text">3.6.2《写final域的重排序规则》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-3%E3%80%8A%E8%AF%BBfinal%E5%9F%9F%E7%9A%84%E9%87%8D%E6%8E%92%E5%BA%8F%E8%A7%84%E5%88%99%E3%80%8B"><span class="nav-number">1.3.6.3.</span> <span class="nav-text">3.6.3《读final域的重排序规则》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-4%E3%80%8Afinal%E5%9F%9F%E4%B8%BA%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%8B"><span class="nav-number">1.3.6.4.</span> <span class="nav-text">3.6.4《final域为引用类型》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-5%E3%80%8A%E4%B8%BA%E4%BB%80%E4%B9%88final%E5%BC%95%E7%94%A8%E4%B8%8D%E8%83%BD%E4%BB%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%86%85%E2%80%9C%E6%BA%A2%E5%87%BA%E2%80%9D%E3%80%8B"><span class="nav-number">1.3.6.5.</span> <span class="nav-text">3.6.5《为什么final引用不能从构造函数内“溢出”》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-6%E3%80%8Afinal%E8%AF%AD%E4%B9%89%E5%9C%A8%E5%A4%84%E7%90%86%E5%99%A8%E4%B8%AD%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%8B"><span class="nav-number">1.3.6.6.</span> <span class="nav-text">3.6.6《final语义在处理器中的实现》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7%E3%80%8Ahappens-before%E3%80%8B"><span class="nav-number">1.3.7.</span> <span class="nav-text">3.7《happens-before》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-1%E3%80%8AJMM%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B"><span class="nav-number">1.3.7.1.</span> <span class="nav-text">3.7.1《JMM的设计》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-2%E3%80%8Ahappens-before%E7%9A%84%E5%AE%9A%E4%B9%89%E3%80%8B"><span class="nav-number">1.3.7.2.</span> <span class="nav-text">3.7.2《happens-before的定义》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-3%E3%80%8Ahappens-before%E8%A7%84%E5%88%99%E3%80%8B"><span class="nav-number">1.3.7.3.</span> <span class="nav-text">3.7.3《happens-before规则》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8%E3%80%8A%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E4%B8%8E%E5%BB%B6%E8%BF%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E3%80%8B"><span class="nav-number">1.3.8.</span> <span class="nav-text">3.8《双重检查锁定与延迟初始化》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-1%E3%80%8A%E5%8F%8C%E9%87%8D%E6%A3%80%E6%9F%A5%E9%94%81%E5%AE%9A%E7%9A%84%E7%94%B1%E6%9D%A5%E3%80%8B"><span class="nav-number">1.3.8.1.</span> <span class="nav-text">3.8.1《双重检查锁定的由来》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-2%E3%80%8A%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%E3%80%8B"><span class="nav-number">1.3.8.2.</span> <span class="nav-text">3.8.2《问题的根源》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-3%E3%80%8A%E5%9F%BA%E4%BA%8Evolatile%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%8B"><span class="nav-number">1.3.8.3.</span> <span class="nav-text">3.8.3《基于volatile的解决方案》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-8-4%E3%80%8A%E5%9F%BA%E4%BA%8E%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E3%80%8B"><span class="nav-number">1.3.8.4.</span> <span class="nav-text">3.8.4《基于类初始化的解决方案》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-9%E3%80%8AJava%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%BB%BC%E8%BF%B0%E3%80%8B"><span class="nav-number">1.3.9.</span> <span class="nav-text">3.9《Java内存模型综述》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-1%E3%80%8A%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E3%80%8B"><span class="nav-number">1.3.9.1.</span> <span class="nav-text">3.9.1《处理器的内存模型》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-2%E3%80%8A%E5%90%84%E7%A7%8D%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB%E3%80%8B"><span class="nav-number">1.3.9.2.</span> <span class="nav-text">3.9.2《各种内存模型之间的关系》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-3%E3%80%8AJMM%E7%9A%84%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%9D%E8%AF%81%E3%80%8B"><span class="nav-number">1.3.9.3.</span> <span class="nav-text">3.9.3《JMM的内存可见性保证》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-9-4%E3%80%8AJSR-133%E5%AF%B9%E6%97%A7%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E7%9A%84%E4%BF%AE%E8%A1%A5%E3%80%8B"><span class="nav-number">1.3.9.4.</span> <span class="nav-text">3.9.4《JSR-133对旧内存模型的修补》</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E3%80%8B"><span class="nav-number">1.4.</span> <span class="nav-text">4.《Java并发编程基础》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E3%80%8A%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B%E3%80%8B"><span class="nav-number">1.4.1.</span> <span class="nav-text">4.1.《线程简介》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-1%E3%80%8A%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.1.1.</span> <span class="nav-text">4.1.1《什么是线程》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-2%E3%80%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.1.2.</span> <span class="nav-text">4.1.2《为什么要使用多线程》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-3%E3%80%8A%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%8B"><span class="nav-number">1.4.1.3.</span> <span class="nav-text">4.1.3《线程优先级》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-4%E3%80%8A%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E3%80%8B"><span class="nav-number">1.4.1.4.</span> <span class="nav-text">4.1.4《线程的状态》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-5%E3%80%8ADaemon%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.1.5.</span> <span class="nav-text">4.1.5《Daemon线程》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2%E3%80%8A%E5%90%AF%E5%8A%A8%E5%92%8C%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.2.</span> <span class="nav-text">4.2《启动和终止线程》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-1%E3%80%8A%E6%9E%84%E9%80%A0%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.2.1.</span> <span class="nav-text">4.2.1《构造线程》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-2%E3%80%8A%E5%90%AF%E5%8A%A8%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.2.2.</span> <span class="nav-text">4.2.2《启动线程》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-3%E3%80%8A%E7%90%86%E8%A7%A3%E4%B8%AD%E6%96%AD%E3%80%8B"><span class="nav-number">1.4.2.3.</span> <span class="nav-text">4.2.3《理解中断》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-4%E3%80%8A%E8%BF%87%E6%9C%9F%E7%9A%84suspend-%E3%80%81resume-%E5%92%8Cstop-%E3%80%8B"><span class="nav-number">1.4.2.4.</span> <span class="nav-text">4.2.4《过期的suspend()、resume()和stop()》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-5%E3%80%8A%E5%AE%89%E5%85%A8%E5%9C%B0%E7%BB%88%E6%AD%A2%E7%BA%BF%E7%A8%8B%E3%80%8B"><span class="nav-number">1.4.2.5.</span> <span class="nav-text">4.2.5《安全地终止线程》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3%E3%80%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E3%80%8B"><span class="nav-number">1.4.3.</span> <span class="nav-text">4.3《线程间通信》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-1%E3%80%8Avolatile%E5%92%8Csynchronized%E5%85%B3%E9%94%AE%E5%AD%97%E3%80%8B"><span class="nav-number">1.4.3.1.</span> <span class="nav-text">4.3.1《volatile和synchronized关键字》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-2%E3%80%8A%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E6%9C%BA%E5%88%B6%E3%80%8B"><span class="nav-number">1.4.3.2.</span> <span class="nav-text">4.3.2《等待&#x2F;通知机制》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-3%E3%80%8A%E7%AD%89%E5%BE%85-%E9%80%9A%E7%9F%A5%E7%9A%84%E7%BB%8F%E5%85%B8%E8%8C%83%E5%BC%8F%E3%80%8B"><span class="nav-number">1.4.3.3.</span> <span class="nav-text">4.3.3《等待&#x2F;通知的经典范式》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-4%E3%80%8A%E7%AE%A1%E9%81%93%E8%BE%93%E5%85%A5-%E8%BE%93%E5%87%BA%E6%B5%81%E3%80%8B"><span class="nav-number">1.4.3.4.</span> <span class="nav-text">4.3.4《管道输入&#x2F;输出流》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-5%E3%80%8AThread-join-%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%8B"><span class="nav-number">1.4.3.5.</span> <span class="nav-text">4.3.5《Thread.join()的使用》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-6%E3%80%8AThreadLocal%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%8B"><span class="nav-number">1.4.3.6.</span> <span class="nav-text">4.3.6《ThreadLocal的使用》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4%E3%80%8A%E7%BA%BF%E7%A8%8B%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%E3%80%8B"><span class="nav-number">1.4.4.</span> <span class="nav-text">4.4《线程应用实例》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1%E3%80%8A%E7%AD%89%E5%BE%85%E8%B6%85%E6%97%B6%E6%A8%A1%E5%BC%8F%E3%80%8B"><span class="nav-number">1.4.4.1.</span> <span class="nav-text">4.4.1《等待超时模式》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2%E3%80%8A%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%E7%A4%BA%E4%BE%8B%E3%80%8B"><span class="nav-number">1.4.4.2.</span> <span class="nav-text">4.4.2《一个简单的数据库连接池示例》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3%E3%80%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E5%8F%8A%E5%85%B6%E7%A4%BA%E4%BE%8B%E3%80%8B"><span class="nav-number">1.4.4.3.</span> <span class="nav-text">4.4.3《线程池技术及其示例》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4%E3%80%8A%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8A%80%E6%9C%AF%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E3%80%8B"><span class="nav-number">1.4.4.4.</span> <span class="nav-text">4.4.4《一个基于线程池技术的简单Web服务器》</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E3%80%8AJava%E4%B8%AD%E7%9A%84%E9%94%81%E3%80%8B"><span class="nav-number">1.5.</span> <span class="nav-text">5.《Java中的锁》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E3%80%8ALock%E6%8E%A5%E5%8F%A3%E3%80%8B"><span class="nav-number">1.5.1.</span> <span class="nav-text">5.1.《Lock接口》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2%E3%80%8A%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E3%80%8B"><span class="nav-number">1.5.2.</span> <span class="nav-text">5.2《队列同步器》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-1%E3%80%8A%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B%E3%80%8B"><span class="nav-number">1.5.2.1.</span> <span class="nav-text">5.2.1《队列同步器的接口与示例》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2%E3%80%8A%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%E3%80%8B"><span class="nav-number">1.5.2.2.</span> <span class="nav-text">5.2.2《队列同步器的实现分析》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3%E3%80%8A%E9%87%8D%E5%85%A5%E9%94%81%E3%80%8B"><span class="nav-number">1.5.3.</span> <span class="nav-text">5.3《重入锁》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4%E3%80%8A%E8%AF%BB%E5%86%99%E9%94%81%E3%80%8B"><span class="nav-number">1.5.4.</span> <span class="nav-text">5.4《读写锁》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-1%E3%80%8A%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B%E3%80%8B"><span class="nav-number">1.5.4.1.</span> <span class="nav-text">5.4.1《读写锁的接口与示例》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-2%E3%80%8A%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%E3%80%8B"><span class="nav-number">1.5.4.2.</span> <span class="nav-text">5.4.2《读写锁的实现分析》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E3%80%8ALockSupport%E5%B7%A5%E5%85%B7%E3%80%8B"><span class="nav-number">1.5.5.</span> <span class="nav-text">5.5.《LockSupport工具》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-%E3%80%8ACondition%E6%8E%A5%E5%8F%A3%E3%80%8B"><span class="nav-number">1.5.6.</span> <span class="nav-text">5.6.《Condition接口》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-1%E3%80%8ACondition%E6%8E%A5%E5%8F%A3%E4%B8%8E%E7%A4%BA%E4%BE%8B%E3%80%8B"><span class="nav-number">1.5.6.1.</span> <span class="nav-text">5.6.1《Condition接口与示例》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-6-2%E3%80%8ACondition%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%88%86%E6%9E%90%E3%80%8B"><span class="nav-number">1.5.6.2.</span> <span class="nav-text">5.6.2《Condition的实现分析》</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E3%80%8AJava%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8%E5%92%8C%E6%A1%86%E6%9E%B6%E3%80%8B"><span class="nav-number">1.6.</span> <span class="nav-text">6.《Java并发容器和框架》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-%E3%80%8AConcurrentHashMap%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E3%80%8B"><span class="nav-number">1.6.1.</span> <span class="nav-text">6.1.《ConcurrentHashMap的实现原理与使用》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-1-%E3%80%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8ConcurrentHashMap%E3%80%8B"><span class="nav-number">1.6.1.1.</span> <span class="nav-text">6.1.1.《为什么要使用ConcurrentHashMap》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-%E3%80%8AConcurrentHashMap%E7%9A%84%E7%BB%93%E6%9E%84%E3%80%8B"><span class="nav-number">1.6.1.2.</span> <span class="nav-text">6.1.2.《ConcurrentHashMap的结构》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-%E3%80%8AConcurrentHashMap%E7%9A%84%E6%93%8D%E4%BD%9C%E3%80%8B"><span class="nav-number">1.6.1.3.</span> <span class="nav-text">6.1.3.《ConcurrentHashMap的操作》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-%E3%80%8AConcurrentLinkedQueue%E3%80%8B"><span class="nav-number">1.6.2.</span> <span class="nav-text">6.2.《ConcurrentLinkedQueue》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-1-%E3%80%8AConcurrentLinkedQueue%E7%9A%84%E7%BB%93%E6%9E%84%E3%80%8B"><span class="nav-number">1.6.2.1.</span> <span class="nav-text">6.2.1.《ConcurrentLinkedQueue的结构》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-2-%E3%80%8A%E5%85%A5%E9%98%9F%E5%88%97%E3%80%8B"><span class="nav-number">1.6.2.2.</span> <span class="nav-text">6.2.2.《入队列》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-3-%E3%80%8A%E5%87%BA%E9%98%9F%E5%88%97%E3%80%8B"><span class="nav-number">1.6.2.3.</span> <span class="nav-text">6.2.3.《出队列》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-%E3%80%8AJava%E4%B8%AD%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E3%80%8B"><span class="nav-number">1.6.3.</span> <span class="nav-text">6.3.《Java中的阻塞队列》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-1-%E3%80%8A%E4%BB%80%E4%B9%88%E6%98%AF%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E3%80%8B"><span class="nav-number">1.6.3.1.</span> <span class="nav-text">6.3.1.《什么是阻塞队列》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-2-%E3%80%8AJava%E9%87%8C%E7%9A%84%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E3%80%8B"><span class="nav-number">1.6.3.2.</span> <span class="nav-text">6.3.2.《Java里的阻塞队列》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-3-%E3%80%8A%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B"><span class="nav-number">1.6.3.3.</span> <span class="nav-text">6.3.3.《阻塞队列的实现原理》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-%E3%80%8AFork-Join%E6%A1%86%E6%9E%B6%E3%80%8B"><span class="nav-number">1.6.4.</span> <span class="nav-text">6.4.《Fork&#x2F;Join框架》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-1%E3%80%8A%E4%BB%80%E4%B9%88%E6%98%AFFork-Join%E6%A1%86%E6%9E%B6%E3%80%8B"><span class="nav-number">1.6.4.1.</span> <span class="nav-text">6.4.1《什么是Fork&#x2F;Join框架》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-2-%E3%80%8A%E5%B7%A5%E4%BD%9C%E7%AA%83%E5%8F%96%E7%AE%97%E6%B3%95%E3%80%8B"><span class="nav-number">1.6.4.2.</span> <span class="nav-text">6.4.2.《工作窃取算法》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-3-%E3%80%8AFork-Join%E6%A1%86%E6%9E%B6%E7%9A%84%E8%AE%BE%E8%AE%A1%E3%80%8B"><span class="nav-number">1.6.4.3.</span> <span class="nav-text">6.4.3.《Fork&#x2F;Join框架的设计》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-4-%E3%80%8A%E4%BD%BF%E7%94%A8Fork-Join%E6%A1%86%E6%9E%B6%E3%80%8B"><span class="nav-number">1.6.4.4.</span> <span class="nav-text">6.4.4.《使用Fork&#x2F;Join框架》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-5-%E3%80%8AFork-Join%E6%A1%86%E6%9E%B6%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E3%80%8B"><span class="nav-number">1.6.4.5.</span> <span class="nav-text">6.4.5.《Fork&#x2F;Join框架的异常处理》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-4-6-%E3%80%8AFork-Join%E6%A1%86%E6%9E%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B"><span class="nav-number">1.6.4.6.</span> <span class="nav-text">6.4.6.《Fork&#x2F;Join框架的实现原理》</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E3%80%8AJava%E4%B8%AD%E7%9A%8413%E4%B8%AA%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9C%E7%B1%BB%E3%80%8B"><span class="nav-number">1.7.</span> <span class="nav-text">7.《Java中的13个原子操作类》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-%E3%80%8A%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E7%B1%BB%E3%80%8B"><span class="nav-number">1.7.1.</span> <span class="nav-text">7.1.《原子更新基本类型类》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-%E3%80%8A%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E6%95%B0%E7%BB%84%E3%80%8B"><span class="nav-number">1.7.2.</span> <span class="nav-text">7.2.《原子更新数组》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-3-%E3%80%8A%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E3%80%8B"><span class="nav-number">1.7.3.</span> <span class="nav-text">7.3.《原子更新引用类型》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-4-%E3%80%8A%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E5%AD%97%E6%AE%B5%E7%B1%BB%E3%80%8B"><span class="nav-number">1.7.4.</span> <span class="nav-text">7.4.《原子更新字段类》</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-%E3%80%8AJava%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB%E3%80%8B"><span class="nav-number">1.8.</span> <span class="nav-text">8.《Java中的并发工具类》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#8-1-%E3%80%8A%E7%AD%89%E5%BE%85%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%AE%8C%E6%88%90%E7%9A%84CountDownLatch%E3%80%8B"><span class="nav-number">1.8.1.</span> <span class="nav-text">8.1.《等待多线程完成的CountDownLatch》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-2-%E3%80%8A%E5%90%8C%E6%AD%A5%E5%B1%8F%E9%9A%9CCyclicBarrier%E3%80%8B"><span class="nav-number">1.8.2.</span> <span class="nav-text">8.2.《同步屏障CyclicBarrier》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-1-%E3%80%8ACyclicBarrier%E7%AE%80%E4%BB%8B%E3%80%8B"><span class="nav-number">1.8.2.1.</span> <span class="nav-text">8.2.1.《CyclicBarrier简介》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-2-%E3%80%8ACyclicBarrier%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E3%80%8B"><span class="nav-number">1.8.2.2.</span> <span class="nav-text">8.2.2.《CyclicBarrier的应用场景》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-2-3-%E3%80%8ACyclicBarrier%E5%92%8CCountDownLatch%E7%9A%84%E5%8C%BA%E5%88%AB%E3%80%8B"><span class="nav-number">1.8.2.3.</span> <span class="nav-text">8.2.3.《CyclicBarrier和CountDownLatch的区别》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-3-%E3%80%8A%E6%8E%A7%E5%88%B6%E5%B9%B6%E5%8F%91%E7%BA%BF%E7%A8%8B%E6%95%B0%E7%9A%84Semaphore%E3%80%8B"><span class="nav-number">1.8.3.</span> <span class="nav-text">8.3.《控制并发线程数的Semaphore》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-4-%E3%80%8A%E7%BA%BF%E7%A8%8B%E9%97%B4%E4%BA%A4%E6%8D%A2%E6%95%B0%E6%8D%AE%E7%9A%84Exchanger%E3%80%8B"><span class="nav-number">1.8.4.</span> <span class="nav-text">8.4.《线程间交换数据的Exchanger》</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E3%80%8AJava%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%8B"><span class="nav-number">1.9.</span> <span class="nav-text">9.《Java中的线程池》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#9-1%E3%80%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E3%80%8B"><span class="nav-number">1.9.1.</span> <span class="nav-text">9.1《线程池的实现原理》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-2-%E3%80%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E3%80%8B"><span class="nav-number">1.9.2.</span> <span class="nav-text">9.2.《线程池的使用》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-1-%E3%80%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%8B"><span class="nav-number">1.9.2.1.</span> <span class="nav-text">9.2.1.《线程池的创建》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-2-%E3%80%8A%E5%90%91%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8F%90%E4%BA%A4%E4%BB%BB%E5%8A%A1%E3%80%8B"><span class="nav-number">1.9.2.2.</span> <span class="nav-text">9.2.2.《向线程池提交任务》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-3-%E3%80%8A%E5%85%B3%E9%97%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%8B"><span class="nav-number">1.9.2.3.</span> <span class="nav-text">9.2.3.《关闭线程池》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-4-%E3%80%8A%E5%90%88%E7%90%86%E5%9C%B0%E9%85%8D%E7%BD%AE%E7%BA%BF%E7%A8%8B%E6%B1%A0%E3%80%8B"><span class="nav-number">1.9.2.4.</span> <span class="nav-text">9.2.4.《合理地配置线程池》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-2-5-%E3%80%8A%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E7%9B%91%E6%8E%A7%E3%80%8B"><span class="nav-number">1.9.2.5.</span> <span class="nav-text">9.2.5.《线程池的监控》</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-%E3%80%8AExecutor%E6%A1%86%E6%9E%B6%E3%80%8B"><span class="nav-number">1.10.</span> <span class="nav-text">10.《Executor框架》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#10-1-%E3%80%8AExecutor%E6%A1%86%E6%9E%B6%E7%AE%80%E4%BB%8B%E3%80%8B"><span class="nav-number">1.10.1.</span> <span class="nav-text">10.1.《Executor框架简介》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-1-%E3%80%8AExecutor%E6%A1%86%E6%9E%B6%E7%9A%84%E4%B8%A4%E7%BA%A7%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9E%8B%E3%80%8B"><span class="nav-number">1.10.1.1.</span> <span class="nav-text">10.1.1.《Executor框架的两级调度模型》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-1-2-%E3%80%8AExecutor%E6%A1%86%E6%9E%B6%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E6%88%90%E5%91%98%E3%80%8B"><span class="nav-number">1.10.1.2.</span> <span class="nav-text">10.1.2.《Executor框架的结构与成员》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-2-%E3%80%8AThreadPoolExecutor%E8%AF%A6%E8%A7%A3%E3%80%8B"><span class="nav-number">1.10.2.</span> <span class="nav-text">10.2.《ThreadPoolExecutor详解》</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-1-%E3%80%8AFixedThreadPool%E8%AF%A6%E8%A7%A3%E3%80%8B"><span class="nav-number">1.10.2.1.</span> <span class="nav-text">10.2.1.《FixedThreadPool详解》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-2-%E3%80%8ASingleThreadExecutor%E8%AF%A6%E8%A7%A3%E3%80%8B"><span class="nav-number">1.10.2.2.</span> <span class="nav-text">10.2.2.《SingleThreadExecutor详解》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-3-%E3%80%8ACachedThreadPool%E8%AF%A6%E8%A7%A3%E3%80%8B"><span class="nav-number">1.10.2.3.</span> <span class="nav-text">10.2.3.《CachedThreadPool详解》</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-2-4-%E3%80%8AScheduledThreadPoolExecutor%E8%AF%A6%E8%A7%A3%E3%80%8B"><span class="nav-number">1.10.2.4.</span> <span class="nav-text">10.2.4.《ScheduledThreadPoolExecutor详解》</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-3-%E3%80%8AFutureTask%E8%AF%A6%E8%A7%A3%E3%80%8B"><span class="nav-number">1.10.3.</span> <span class="nav-text">10.3.《FutureTask详解》</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E3%80%8AJava%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5%E3%80%8B"><span class="nav-number">1.11.</span> <span class="nav-text">11.《Java并发编程实践》</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#11-1-%E3%80%8A%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%BC%8F%E3%80%8B"><span class="nav-number">1.11.1.</span> <span class="nav-text">11.1.《生产者和消费者模式》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-2-%E3%80%8A%E7%BA%BF%E4%B8%8A%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D%E3%80%8B"><span class="nav-number">1.11.2.</span> <span class="nav-text">11.2.《线上问题定位》</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-3-%E3%80%8A%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E3%80%8B"><span class="nav-number">1.11.3.</span> <span class="nav-text">11.3.《性能测试》</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">不登山峰，不显平地</p>
  <div class="site-description" itemprop="description">木鱼者，相传云，鱼昼夜常醒，刻木像形击之，所以警昏情也。</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">383</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">36</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">63</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/lark-coder" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;lark-coder" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">不登山峰，不显平地</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">793k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">12:01</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
